<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tactical Chat Interface</title>
    <!-- Favicon for military icon -->
    <link rel="icon" href="https://upload.wikimedia.org/wikipedia/commons/e/ea/Tactical_symbol_Land_Forces_-_Motorized_infantry_-_Squad_-_NATO_APP-6A.svg" type="image/svg+xml">
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Custom scrollbar for message area - military green/grey */
        .message-area::-webkit-scrollbar {
            width: 8px;
        }

        .message-area::-webkit-scrollbar-track {
            background: #2d3748; /* Darker track */
            border-radius: 10px;
        }

        .message-area::-webkit-scrollbar-thumb {
            background: #4a5568; /* Muted grey thumb */
            border-radius: 10px;
        }

        .message-area::-webkit-scrollbar-thumb:hover {
            background: #6a7486; /* Slightly lighter on hover */
        }

        /* Styling for emoji picker */
        .emoji-picker {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(32px, 1fr));
            gap: 4px;
            padding: 12px;
            background-color: #1a202c; /* Dark background */
            border-radius: 8px; /* Slightly less rounded for a tactical feel */
            box-shadow: 0 4px 15px rgba(0, 255, 0, 0.2); /* Green glow effect */
            max-height: 250px;
            overflow-y: auto;
            position: absolute;
            bottom: calc(100% + 10px);
            left: 50%;
            transform: translateX(-50%);
            max-width: 350px; /* Adjust as needed */
            width: 90%; /* Responsive width */
            z-index: 50;
            border: 1px solid #10b981; /* Accent green border */
        }

        .emoji-picker button {
            font-size: 28px;
            background: none;
            border: none;
            cursor: pointer;
            padding: 6px;
            border-radius: 4px; /* Sharper corners */
            transition: background-color 0.2s ease, transform 0.1s ease;
        }

        .emoji-picker button:hover {
            background-color: rgba(0, 255, 0, 0.1); /* Subtle green tint on hover */
            transform: scale(1.05);
        }

        .emoji-picker button:active {
            background-color: rgba(0, 255, 0, 0.2);
            transform: scale(0.98);
        }

        /* Custom alert message styling */
        .app-alert {
            box-shadow: 0 4px 15px rgba(0,0,0,0.4);
            transition: all 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            font-family: 'Roboto Mono', monospace; /* Technical font for alerts */
        }

        /* Recording specific styles */
        .record-button-active {
            animation: pulse-red 1s infinite;
        }

        @keyframes pulse-red {
            0% { box-shadow: 0 0 0 0 rgba(239, 68, 68, 0.7); }
            70% { box-shadow: 0 0 0 10px rgba(239, 68, 68, 0); }
            100% { box-shadow: 0 0 0 0 rgba(239, 68, 68, 0); }
        }

        /* Online status indicators */
        .status-dot {
            display: inline-block;
            width: 8px;
            height: 8px;
            border-radius: 50%;
            margin-left: 6px;
            background-color: #ccc; /* Default grey for unknown/offline */
        }
        .status-dot.online {
            background-color: #10b981; /* Green */
        }
        .status-dot.offline {
            background-color: #ef4444; /* Red */
        }
        .status-text {
            font-size: 0.75rem; /* text-xs */
            margin-left: 4px;
            opacity: 0.7;
        }
        .status-text.online {
            color: #10b981; /* Green */
        }
        .status-text.offline {
            color: #ef4444; /* Red */
        }

        /* Typing indicator specific styles */
        .typing-indicator {
            display: flex;
            align-items: center;
            font-size: 0.75rem; /* text-xs */
            color: #10b981; /* Green */
            opacity: 0.8;
            margin-top: 5px;
        }
        .typing-indicator span {
            animation: blink 1s infinite;
            animation-delay: var(--delay);
        }
        @keyframes blink {
            0%, 100% { opacity: 0; }
            50% { opacity: 1; }
        }

        /* Online Users Modal Styles */
        .online-users-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7); /* Semi-transparent dark overlay */
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 100;
        }

        .online-users-modal-content {
            background-color: #1a202c; /* Dark background */
            padding: 24px;
            border-radius: 8px;
            box-shadow: 0 8px 30px rgba(0, 255, 0, 0.3); /* Green glow */
            width: 90%;
            max-width: 400px;
            max-height: 80%;
            overflow-y: auto;
            border: 1px solid #10b981;
            position: relative; /* For close button positioning */
        }

        .online-users-modal-content h3 {
            font-size: 1.5rem;
            color: #10b981; /* Green */
            margin-bottom: 16px;
            text-align: center;
            font-weight: bold;
            text-transform: uppercase;
        }

        .online-users-modal-content ul {
            list-style: none;
            padding: 0;
            margin: 0;
        }

        .online-users-modal-content ul li {
            background-color: #2d3748; /* Slightly lighter dark */
            padding: 10px 15px;
            border-radius: 5px;
            margin-bottom: 8px;
            display: flex;
            align-items: center; /* Align items for profile pic */
            justify-content: space-between;
            font-size: 1rem;
            color: #e2e8f0; /* Light gray */
            border: 1px solid #4a5568;
            cursor: pointer; /* Indicate clickable */
            transition: background-color 0.2s ease, transform 0.1s ease;
        }

        .online-users-modal-content ul li:hover {
            background-color: rgba(16, 185, 129, 0.2); /* Light green tint on hover */
            transform: translateY(-2px);
        }

        .online-users-modal-content ul li:last-child {
            margin-bottom: 0;
        }

        .modal-close-button {
            position: absolute;
            top: 10px;
            right: 10px;
            background: none;
            border: none;
            font-size: 1.5rem;
            color: #ef4444; /* Red */
            cursor: pointer;
            padding: 5px;
            line-height: 1;
            transition: transform 0.2s ease;
        }

        .modal-close-button:hover {
            transform: scale(1.1);
        }

        /* Private Message Notification Dot */
        .pm-notification-dot {
            display: inline-block;
            width: 10px;
            height: 10px;
            background-color: #ef4444; /* Red */
            border-radius: 50%;
            margin-left: 8px;
            animation: pulse-red 1s infinite;
        }
        .pm-notification-dot.hidden {
            display: none;
        }

        /* Generic modal overlay and content */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 100;
        }

        .modal-content {
            background-color: #1a202c;
            padding: 24px;
            border-radius: 8px;
            box-shadow: 0 8px 30px rgba(0, 255, 0, 0.3);
            width: 90%;
            max-width: 400px;
            border: 1px solid #10b981;
            position: relative;
        }

        /* Profile Picture specific styles */
        .profile-pic-thumbnail {
            width: 24px;
            height: 24px;
            border-radius: 50%;
            border: 1px solid rgba(16, 185, 129, 0.5); /* Green border */
            margin-right: 8px; /* Space from callsign */
            flex-shrink: 0; /* Prevent shrinking */
            
            display: flex; /* Make it a flex container */
            justify-content: center; /* Center horizontally */
            align-items: center; /* Center vertically */
            font-size: 16px; /* Adjust font size to fit */
            line-height: 1; /* Ensure no extra line height for emoji */
        }
        .profile-pic-large {
            width: 100px;
            height: 100px;
            border-radius: 50%;
            border: 2px solid #10b981;
            margin-bottom: 15px;
            display: flex; /* Use flex to center the emoji */
            justify-content: center;
            align-items: center;
            font-size: 60px; /* Make emoji large */
            line-height: 1; /* Ensure no extra line height for emoji */
        }

        /* Loading indicator for file uploads */
        .upload-loading-indicator {
            display: none;
            margin-top: 10px;
            color: #10b981;
            font-size: 0.8rem;
        }

        /* Avatar emoji picker (for the new, separate modal) */
        .avatar-emoji-picker {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(30px, 1fr)); /* More emojis per row */
            gap: 6px; /* Slightly reduced gap */
            padding: 8px; /* Reduced padding */
            background-color: #2d3748;
            border-radius: 8px;
            border: 1px solid #4a5568;
            max-height: 180px; /* Reduced max-height */
            overflow-y: auto;
            margin-top: 15px;
            margin-bottom: 15px;
            max-width: 280px; /* Constrain max-width for smaller size */
        }
        .avatar-emoji-picker button {
            font-size: 24px; /* Slightly reduced font size */
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px; /* Reduced padding */
            border-radius: 6px;
            transition: background-color 0.2s ease, transform 0.1s ease;
        }
        .avatar-emoji-picker button:hover {
            background-color: rgba(16, 185, 129, 0.15);
            transform: scale(1.1);
        }
        .avatar-emoji-picker button.selected {
            background-color: #10b981;
            box-shadow: 0 0 0 2px rgba(16, 185, 129, 0.5);
            transform: scale(1.05);
        }

        /* New styles for the avatar selection modal specific content */
        .avatar-selection-modal .modal-content {
            max-width: 320px; /* Smaller max width for this modal */
            padding: 15px; /* Reduced padding */
        }
        .avatar-selection-modal .modal-content h3 {
            font-size: 1.2rem; /* Smaller title */
            margin-bottom: 10px;
        }
    </style>
    <!-- Add Google Fonts for a technical look (e.g., Roboto Mono or Oxanium) -->
    <link href="https://fonts.googleapis.com/css2?family=Roboto+Mono:wght@400;700&family=Oxanium:wght@400;700&display=swap" rel="stylesheet">
</head>
<body class="bg-gray-950 min-h-screen flex items-center justify-center p-0 font-['Roboto_Mono'] text-green-300 selection:bg-green-500 selection:text-white">

    <!-- Password Entry Screen -->
    <div id="password-screen" class="absolute inset-0 bg-gray-950 flex items-center justify-center z-50">
        <div class="bg-gray-900 p-8 rounded-lg shadow-xl border border-gray-700 text-center flex flex-col gap-6 w-11/12 max-w-sm">
            <h2 class="text-xl md:text-2xl font-bold text-green-400 tracking-wider uppercase font-['Oxanium']">Access Protocol</h2>
            <p class="text-gray-400 text-sm">Enter security key to proceed.</p>
            <input
                type="password"
                id="password-input"
                placeholder="Security Key"
                class="p-3 rounded-sm border border-green-700 focus:outline-none focus:ring-1 focus:ring-green-500 bg-gray-700 text-green-300 text-base transition duration-200"
            />
            <button
                id="login-button"
                class="bg-green-600 hover:bg-green-500 active:bg-green-700 text-white font-bold py-3 px-6 rounded-sm transition duration-300 ease-in-out shadow-lg hover:shadow-xl focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-green-500 border border-green-700 w-full"
            >
                Authorize
            </button>
            <p id="password-error" class="text-red-500 text-sm hidden">Access Denied. Invalid Key.</p>
        </div>
    </div>

    <!-- Authentication Options Screen (Now removed from flow, kept as hidden placeholder) -->
    <div id="auth-options-screen" class="modal-overlay hidden">
        <div class="modal-content text-center flex flex-col gap-6">
            <h3 class="text-xl md:text-2xl font-bold text-green-400 tracking-wider uppercase font-['Oxanium']">Identify Self</h3>
            <button class="bg-blue-600 text-white font-bold py-3 px-6 rounded-sm w-full">
                This screen should not be visible.
            </button>
        </div>
    </div>

    <!-- Email/Password Signup/Login Modal -->
    <div id="signup-login-modal" class="modal-overlay hidden">
        <div class="modal-content text-center flex flex-col gap-6">
            <button class="modal-close-button" id="signup-login-close-button">&times;</button>
            <h3 id="auth-modal-title" class="text-xl md:text-2xl font-bold text-green-400 tracking-wider uppercase font-['Oxanium']">Create Call-Sign</h3>
            <input
                type="email"
                id="auth-email-input"
                placeholder="Email Address (For Retrieval)"
                class="p-3 rounded-sm border border-green-700 focus:outline-none focus:ring-1 focus:ring-green-500 bg-gray-700 text-green-300 text-base transition duration-200"
            />
            <input
                type="password"
                id="auth-password-input"
                placeholder="Secure Key (Password)"
                class="p-3 rounded-sm border border-green-700 focus:outline-none focus:ring-1 focus:ring-green-500 bg-gray-700 text-green-300 text-base transition duration-200"
            />
            <input
                type="text"
                id="auth-callsign-input"
                placeholder="Your Callsign (e.g., 'Alpha-7')"
                class="p-3 rounded-sm border border-green-700 focus:outline-none focus:ring-1 focus:ring-green-500 bg-gray-700 text-green-300 text-base transition duration-200 hidden"
                maxlength="15"
            />
            <button
                id="auth-submit-button"
                class="bg-green-600 hover:bg-green-500 active:bg-green-700 text-white font-bold py-3 px-6 rounded-sm transition duration-300 ease-in-out shadow-lg hover:shadow-xl focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-green-500 border border-green-700 w-full"
            >
                Register
            </button>
            <p id="auth-error-message" class="text-red-500 text-sm hidden"></p>
            <p class="text-gray-400 text-sm">
                <span id="toggle-auth-mode-text">Already registered?</span>
                <a href="#" id="toggle-auth-mode-link" class="text-blue-400 hover:text-blue-300 transition-colors duration-200">Log In</a>
            </p>
        </div>
    </div>


    <!-- Main Chat Container: Industrial, dark panel look - Initially hidden -->
    <div id="chat-app-container" class="bg-gray-900 rounded-lg shadow-xl overflow-hidden w-full h-screen sm:h-[95vh] sm:max-h-[900px] sm:w-[90vw] sm:max-w-5xl flex flex-col border border-gray-700 transition-all duration-300 ease-in-out hidden">
        <!-- Chat Header -->
        <div class="bg-gray-800 p-2 md:p-4 flex flex-col md:flex-row justify-between items-center gap-y-2 md:gap-x-3 shadow-inner border-b border-green-500 flex-shrink-0">
            <h1 class="text-lg md:text-2xl font-bold text-green-400 text-center md:text-left tracking-wider uppercase font-['Oxanium']">REX Comms</h1>
            <!-- User Info and Online Users sections -->
            <div class="flex flex-col md:flex-row items-center md:justify-end gap-y-1 md:gap-x-2 w-full md:w-auto">
                <div id="user-info" class="text-xs md:text-sm font-medium text-gray-400 flex items-center cursor-pointer" title="Manage Profile">
                    <span id="my-profile-pic-thumb" class="profile-pic-thumbnail flex items-center justify-center"></span>
                    <span class="font-bold text-green-400">Unit:</span> <span id="display-user-id" class="font-extrabold text-green-300 ml-1">UNKNOWN</span> <span id="my-status-indicator" class="status-dot ml-2"></span>
                </div>
                <div id="online-users-indicator" class="flex items-center text-xs md:text-sm font-medium text-gray-400 ml-4 cursor-pointer hover:text-green-300 transition-colors duration-200" title="Click to see online users">
                    <span class="font-bold text-green-400">Online:</span> <span id="online-count" class="font-extrabold text-green-300 ml-1">0</span>
                    <span id="pm-notification-badge" class="pm-notification-dot hidden"></span>
                </div>
            </div>
        </div>

        <!-- Current Chat Info -->
        <div id="chat-context-info" class="bg-gray-800 p-2 md:p-3 text-center text-sm md:text-base border-b border-gray-700 text-gray-400 font-bold flex items-center justify-center gap-2">
            <span id="current-chat-title">Public Channel</span>
            <button id="leave-private-chat-button" class="ml-2 px-3 py-1 bg-red-700 hover:bg-red-600 active:bg-red-800 text-white text-xs rounded-full hidden" title="Return to Public Channel">Exit Private</button>
        </div>

        <!-- Message Area -->
        <div id="message-area" class="flex-grow p-4 md:p-6 overflow-y-auto space-y-4 message-area bg-gray-900 border-t border-b border-gray-800">
            <div id="loading-indicator" class="text-center text-gray-500 mt-8 text-sm md:text-base">Awaiting Transmission...</div>
            <div id="typing-indicator" class="typing-indicator hidden">
                <span style="--delay: 0s;">.</span><span style="--delay: 0.2s;">.</span><span style="--delay: 0.4s;">.</span> Someone is typing...
            </div>
        </div>

        <!-- Message Input and Emoji/Voice Controls -->
        <div class="bg-gray-800 p-3 border-t border-gray-700 flex flex-col relative flex-shrink-0">
            <!-- Emoji Picker -->
            <div id="emoji-picker" class="emoji-picker hidden">
            </div>

            <!-- Row 1: Text Input -->
            <div class="flex-grow mb-2">
                <input
                    type="text"
                    id="message-input"
                    placeholder="Enter message protocol..."
                    class="w-full p-2 md:p-2.5 rounded-sm border border-gray-600 focus:outline-none focus:ring-2 focus:ring-green-500 bg-gray-700 text-green-300 text-sm md:text-lg transition duration-200"
                />
            </div>

            <!-- Row 2: Send Button and Multimedia Buttons -->
            <div class="flex items-center gap-2 md:gap-3">
                <button
                    id="send-button"
                    class="bg-green-600 hover:bg-green-500 active:bg-green-700 text-white font-bold py-2 px-4 md:py-2.5 md:px-5 rounded-sm transition duration-300 ease-in-out shadow-lg hover:shadow-xl focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-green-500 border border-green-700 flex-shrink-0"
                >
                    Transmit
                </button>

                <div class="flex-grow"></div>

                <!-- Voice Recording Buttons -->
                <button
                    id="record-voice-button"
                    class="text-lg md:text-xl p-1.5 rounded-full bg-red-700 hover:bg-red-600 active:bg-red-800 text-white transition duration-300 ease-in-out shadow-sm hover:shadow-md focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-red-500 border border-red-800 flex-shrink-0"
                    title="Record Audio Log"
                >
                    üé§
                </button>
                <button
                    id="stop-record-button"
                    class="text-xs md:text-sm p-1 md:p-1.5 rounded-sm bg-red-600 hover:bg-red-500 active:bg-red-700 text-white font-semibold hidden transition duration-300 ease-in-out shadow-sm hover:shadow-md focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-red-400 border border-red-700 flex-shrink-0"
                    title="Terminate Recording"
                >
                    üõë Stop
                </button>
                <button
                    id="send-voice-button"
                    class="bg-lime-600 hover:bg-lime-500 active:bg-lime-700 text-white font-bold py-1.5 px-3 md:py-1.5 px-3.5 rounded-sm hidden transition duration-300 ease-in-out shadow-md hover:shadow-lg focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-lime-500 border border-lime-700 flex-shrink-0"
                    title="Transmit Audio Log"
                >
                    ‚ñ∂Ô∏è Send
                </button>
                <span id="recording-status" class="text-red-500 font-semibold hidden whitespace-nowrap ml-2 text-xs">Recording Audio...</span>

                <!-- Image/GIF Input and Send Button -->
                <label for="image-input"
                    class="text-lg md:text-xl p-1.5 rounded-full bg-blue-700 hover:bg-blue-600 active:bg-blue-800 text-white transition duration-300 ease-in-out shadow-sm hover:shadow-md cursor-pointer focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500 border border-blue-800 flex-shrink-0"
                    title="Attach Image/GIF"
                    id="attach-media-button-label"
                >
                    üì∏
                    <input type="file" id="image-input" accept="image/*" class="hidden">
                </label>

                <button
                    id="send-media-button"
                    class="bg-blue-600 hover:bg-blue-500 active:bg-blue-700 text-white font-bold py-1.5 px-3 md:py-1.5 px-3.5 rounded-sm hidden transition duration-300 ease-in-out shadow-md hover:shadow-lg focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500 border border-blue-700 flex-shrink-0"
                    title="Transmit Media"
                >
                    üîó Send
                </button>
                <span id="media-preview-status" class="text-blue-500 font-semibold hidden whitespace-nowrap ml-2 text-xs">Media ready...</span>

                <!-- Emoji Button -->
                <button
                    id="emoji-button"
                    class="text-lg md:text-xl p-1.5 rounded-full bg-gray-700 hover:bg-gray-600 active:bg-gray-800 text-yellow-300 transition duration-300 ease-in-out shadow-sm hover:shadow-md focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-gray-400 border border-gray-600 flex-shrink-0"
                    title="Insert Protocol Icon"
                >
                    üòä
                </button>
            </div>
        </div>
    </div>

    <!-- Online Users Modal -->
    <div id="online-users-modal" class="online-users-modal hidden">
        <div class="online-users-modal-content">
            <button class="modal-close-button" id="online-users-close-button">&times;</button>
            <h3>Online Operatives</h3>
            <ul id="online-users-list">
            </ul>
        </div>
    </div>

    <!-- Profile Management Modal -->
    <div id="profile-modal" class="modal-overlay hidden">
        <div class="modal-content text-center flex flex-col items-center gap-4">
            <button class="modal-close-button" id="profile-modal-close-button">&times;</button>
            <h3 class="text-xl md:text-2xl font-bold text-green-400 tracking-wider uppercase font-['Oxanium']">Operative Profile</h3>
            
            <div id="profile-pic-preview" class="profile-pic-large cursor-pointer" title="Change Avatar"></div>
            
            <label for="profile-callsign-input" class="text-gray-400 text-sm">Callsign:</label>
            <input
                type="text"
                id="profile-callsign-input"
                placeholder="Your Callsign"
                class="p-2 rounded-sm border border-green-700 focus:outline-none focus:ring-1 focus:ring-green-500 bg-gray-700 text-green-300 text-base transition duration-200 w-full"
                maxlength="15"
            />
             <label for="profile-custom-status-input" class="text-gray-400 text-sm">Custom Status:</label>
            <input
                type="text"
                id="profile-custom-status-input"
                placeholder="e.g., 'On Patrol', 'Offline for Debrief'"
                class="p-2 rounded-sm border border-green-700 focus:outline-none focus:ring-1 focus:ring-green-500 bg-gray-700 text-green-300 text-base transition duration-200 w-full"
                maxlength="50"
            />
            
            <button
                id="save-profile-button"
                class="bg-green-600 hover:bg-green-500 active:bg-green-700 text-white font-bold py-2 px-5 rounded-sm transition duration-300 ease-in-out shadow-lg hover:shadow-xl focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-green-500 border border-green-700 w-full"
            >
                Save Profile
            </button>
            <p id="profile-error-message" class="text-red-500 text-sm hidden"></p>
        </div>
    </div>

    <!-- NEW: Avatar Selection Modal -->
    <div id="avatar-selection-modal" class="modal-overlay hidden">
        <div class="modal-content text-center avatar-selection-modal">
            <button class="modal-close-button" id="avatar-selection-close-button">&times;</button>
            <h3 class="text-green-400 tracking-wider uppercase font-['Oxanium'] mb-4">Select Avatar Icon</h3>
            <div id="avatar-emoji-picker" class="avatar-emoji-picker">
                <!-- Emojis will be populated here by JavaScript -->
            </div>
        </div>
    </div>


    <!-- Hidden audio element for chat notification sound -->
    <audio id="chat-sound" preload="auto">
        <source src="data:audio/mpeg;base64,SUQzBAAAAAAAI1RTU0UAAAAPAAADTGF2ZjU2LjQwLjEwMABMVU0zLjEwMFpDbgAAAAAAAAAAAAAAAAAAAAAAAAAA//tDEAAAKgAAAHwAAAEyAAABtAAAAYABxAAAk0AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD/8xMNAAsAAGAAAAhCQgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP/7QxAAAAoAAAB8AAAAQjAAABtAAAEyAAACwAAAB8AAALAAAATjAAADQAAAAeAAAAPAAAAhCQAQCAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP/zEzUAGIAAAAYAAAAvQgAAAIAAP/zEzNABsAAAAYAAABLkIgAAAAAA//tDcQAAoAAAAHwAAAEIeXRhY3RTAAAAJGNvcHlyaWdodCBPc2NhciBTeW50aCBTb2x1dGlvbnNQAQAAAABpYW1lAAAAACQAAAEAAAP/zEzUAAwAAAZAAAACvQgAAAAAAAAAAP/zEzUAYgAAABcAAAAEQmQAAAAeAAAAPAAAAhCQAQCAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP/zEzUAAwAAAZAAAACvQgAAAAAAAAAAP/zEzUAGIAAAAYAAABLkIgAAAAAA//tDcQAAoAAAAHwAAAEIeXRhZGVhAAAkY29wePlyaW5odCBPc2NhciBTeW50aCBTb2x1dGlvbnNQAQAAAABpYW1lAAAAACQAAAEAAAP/zEzUAAwAAAZAAAACvQgAAAAAAAAAAP/zEzUAYgAAABcAAAAEQmQAAAAeAAAAPAAAAhCQAQCAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD/8xM1AAMAAAGQAAAAy0IAAAAAAAAAAA==" type="audio/mpeg">
        Your browser does not support the audio element.
    </audio>

    <script type="module">
        // Import Firebase functions from the SDKs
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.9.1/firebase-app.js";
        import { getDatabase, ref, push, onValue, set, onDisconnect, serverTimestamp, get, query, orderByChild, remove, child, update } from "https://www.gstatic.com/firebasejs/11.9.1/firebase-database.js";
        import { getAuth, onAuthStateChanged, createUserWithEmailAndPassword, signInWithEmailAndPassword, linkWithCredential, EmailAuthProvider } from "https://www.gstatic.com/firebasejs/11.9.1/firebase-auth.js";
        // New: Import Firebase Storage functions (though not directly used for avatar emojis, keeping for other potential future uses)
        import { getStorage, ref as storageRef, uploadBytesResumable, getDownloadURL } from "https://www.gstatic.com/firebasejs/11.9.1/firebase-storage.js";


        // Your web app's Firebase configuration (provided by the user)
        const firebaseConfig = {
          apiKey: "AIzaSyB2GAHcBAXb_vni8t7sVzkzcaE1AeOGagk",
          authDomain: "rexcomms-d6d98.firebaseapp.com",
          databaseURL: "https://rexcomms-d6d98-default-rtdb.asia-southeast1.firebasedatabase.app",
          projectId: "rexcomms-d6d98",
          storageBucket: "rexcomms-d6d98.firebasestorage.app",
          messagingSenderId: "1050880314920",
          appId: "1:1050880314920:web:0675ceb39cacf69fa3ef1d"
            
        };

        // Initialize Firebase
        const app = initializeApp(firebaseConfig);
        const db = getDatabase(app);
        const auth = getAuth(app);
        const storage = getStorage(app); // Keeping for other potential future uses if needed


        // Access global variables for app ID
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';

        // DOM elements for password screen
        const passwordScreen = document.getElementById('password-screen');
        const passwordInput = document.getElementById('password-input');
        const loginButton = document.getElementById('login-button');
        const passwordError = document.getElementById('password-error');
        const chatAppContainer = document.getElementById('chat-app-container');

        // Authentication Modals
        const signupLoginModal = document.getElementById('signup-login-modal');
        const signupLoginCloseButton = document.getElementById('signup-login-close-button');
        const authModalTitle = document.getElementById('auth-modal-title');
        const authEmailInput = document.getElementById('auth-email-input');
        const authPasswordInput = document.getElementById('auth-password-input');
        const authCallsignInput = document.getElementById('auth-callsign-input');
        const authSubmitButton = document.getElementById('auth-submit-button');
        const authErrorMessage = document.getElementById('auth-error-message');
        const toggleAuthModeText = document.getElementById('toggle-auth-mode-text');
        const toggleAuthModeLink = document.getElementById('toggle-auth-mode-link');

        // DOM elements for chat interface
        const messageInput = document.getElementById('message-input');
        const sendButton = document.getElementById('send-button');
        const messageArea = document.getElementById('message-area'); 
        const displayUserId = document.getElementById('display-user-id');
        const emojiButton = document.getElementById('emoji-button');
        const emojiPicker = document.getElementById('emoji-picker');
        const chatSound = document.getElementById('chat-sound');
        const myStatusIndicator = document.getElementById('my-status-indicator');
        // Profile elements in header
        const userInfoHeader = document.getElementById('user-info'); 
        const myProfilePicThumb = document.getElementById('my-profile-pic-thumb'); // Now a span for emoji

        // Voice message elements
        const recordVoiceButton = document.getElementById('record-voice-button');
        const stopRecordButton = document.getElementById('stop-record-button');
        const sendVoiceButton = document.getElementById('send-voice-button');
        const recordingStatus = document.getElementById('recording-status');

        // Image/GIF message elements
        const imageInput = document.getElementById('image-input'); // This is the file input for both images and GIFs
        const attachMediaButtonLabel = document.getElementById('attach-media-button-label'); // Label for the file input
        const sendMediaButton = document.getElementById('send-media-button'); // The send button for images/GIFs
        const mediaPreviewStatus = document.getElementById('media-preview-status'); // Status text for images/GIFs

        // Online Users Modal elements
        const onlineUsersIndicator = document.getElementById('online-users-indicator');
        const onlineCountSpan = document.getElementById('online-count');
        const onlineUsersModal = document.getElementById('online-users-modal');
        const onlineUsersList = document.getElementById('online-users-list');
        const onlineUsersCloseButton = document.getElementById('online-users-close-button');
        const pmNotificationBadge = document.getElementById('pm-notification-badge');

        // Private Chat elements
        const chatContextInfo = document.getElementById('chat-context-info');
        const currentChatTitle = document.getElementById('current-chat-title');
        const leavePrivateChatButton = document.getElementById('leave-private-chat-button');

        // Profile Modal elements
        const profileModal = document.getElementById('profile-modal');
        const profileModalCloseButton = document.getElementById('profile-modal-close-button');
        const profilePicPreview = document.getElementById('profile-pic-preview'); // Now a div for emoji
        const profileCallsignInput = document.getElementById('profile-callsign-input');
        const profileCustomStatusInput = document.getElementById('profile-custom-status-input');
        const saveProfileButton = document.getElementById('save-profile-button');
        const profileErrorMessage = document.getElementById('profile-error-message');

        // NEW Avatar Selection Modal elements
        const avatarSelectionModal = document.getElementById('avatar-selection-modal');
        const avatarSelectionCloseButton = document.getElementById('avatar-selection-close-button');
        const avatarEmojiPicker = document.getElementById('avatar-emoji-picker');


        // Voice message variables
        let mediaRecorder;
        let audioChunks = [];
        let audioBlob = null;
        let audioMimeType = '';

        // Image/GIF message variables
        let selectedMediaBase64 = null;
        let selectedMediaMimeType = null;

        // Typing indicator variables
        let typingTimeout = null;
        const TYPING_INDICATOR_TIMEOUT_MS = 3000; // Time after which typing status is cleared

        // Private chat variables
        let currentPrivateChatUserId = null; // Stores the userId of the user in a private chat
        let currentPrivateChatDisplayName = null; // Stores the displayName of the chat partner


        // Persistent User ID and Display Name
        let currentUserId = null;
        // The old placeholder image URL that might be present in old data
        const OLD_PLACEHOLDER_URL = "https://placehold.co/24x24/1a202c/e2e8f0?text=P";
        
        // Initial profile pic is now a default emoji, not a placeholder image
        let currentDisplayName = localStorage.getItem('chatDisplayName') || `Unit-UNKNOWN`;
        let currentProfilePicUrl = localStorage.getItem('chatProfilePicUrl');
        // If the stored profile pic is the old placeholder, reset it to a default emoji
        if (currentProfilePicUrl === null || currentProfilePicUrl === OLD_PLACEHOLDER_URL || currentProfilePicUrl === '') {
            currentProfilePicUrl = 'üòÄ'; 
            localStorage.setItem('chatProfilePicUrl', currentProfilePicUrl); // Update local storage
        }
        let currentCustomStatus = localStorage.getItem('chatCustomStatus') || '';

        // NEW: Temporary variable for avatar selection before saving
        let tempProfilePicSelection = currentProfilePicUrl;


        // Global map to store online status and typing status of all users
        let userPresenceMap = {};
        // Timestamp of the last message processed for sound/notification
        let lastProcessedMessageTimestamp = 0;

        const CORRECT_PASSWORD = "rexchat";
        let authMode = 'signup'; // 'signup' or 'login'

        // NEW: Array of avatar emojis
        const avatarEmojis = [
            'üòÄ', 'üòÅ', 'üòÇ', 'ü§£', 'üòÉ', 'üòÑ', 'üòÖ', 'üòÜ', 'üòá', 'ÔøΩ',
            'üòâ', 'üòä', 'üòã', 'üòå', 'üòé', 'ü§ì', 'üßê', 'üòè', 'üòÆ', 'ü§î', 
            'ü§®', 'üòê', 'üòë', 'üò∂', 'ü§´', 'ü§•', 'üò¨', 'üòÆ‚Äçüí®', 'üò¥', 'ü§§',
            'üò∑', 'ü§í', 'ü§ï', 'ü§¢', 'ü§Æ', 'ü§ß', 'ü•µ', 'ü•∂', 'üòµ', 'ü§Ø',
            'ü§†', 'ü•≥', 'üòé', 'ü•∏', 'ü•∫', 'üò§', 'üò°', 'üò†', 'ü§¨', 'üò≥',
            'üò±', 'üò®', 'üò∞', 'üò•', 'üò¢', 'üò≠', 'ü§Ø', 'üò¨', 'üò©', 'ü•∫',
            'üë©‚ÄçüöÄ', 'üßë‚Äçüíª', 'ü•∑', 'üïµÔ∏è', 'üíÇ', 'üë∑', 'üë®‚Äçüî¨', 'üë©‚Äçüî¨', 'ü§ñ', 'üëæ',
            'üê∂', 'üê±', 'üê≠', 'üêπ', 'üê∞', 'ü¶ä', 'üêª', 'üêº', 'üê®', 'üêØ',
            'ü¶Å', 'üêÆ', 'üê∑', 'üê∏', 'üêµ', 'üêî', 'üêß', 'üê¶', 'ü¶â', 'ü¶Ü'
        ];


        /**
         * Requests notification permission from the user.
         */
        function requestNotificationPermission() {
            if (!("Notification" in window)) {
                console.log("This browser does not support desktop notification");
                return;
            }

            if (Notification.permission === "granted") {
                console.log("Notification permission already granted.");
            } else if (Notification.permission !== "denied") {
                Notification.requestPermission().then(permission => {
                    if (permission === "granted") {
                        console.log("Notification permission granted.");
                    } else {
                        console.log("Notification permission denied.");
                    }
                });
            }
        }

        /**
         * Requests microphone permission.
         */
        async function requestMicrophonePermission() {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                console.log("Microphone permission granted.");
                stream.getTracks().forEach(track => track.stop());
            } catch (err) {
                console.warn("Microphone permission denied or an error occurred:", err);
                alertMessage("Microphone access denied. Voice messages will not be available.", 'red');
            }
        }

        /**
         * Displays a browser notification for a new message.
         * @param {string} title - The title of the notification.
         * @param {string} body - The body text of the notification.
         */
        function displayNotification(title, body) {
            if (Notification.permission === "granted" && !document.hidden) {
                return;
            } else if (Notification.permission === "granted") {
                new Notification(title, {
                    body: body,
                    icon: 'https://placehold.co/48x48/00FF00/FFFFFF?text=Chat',
                    vibrate: [200, 100, 200]
                });
            }
        }

        /**
         * Resets the input area to its default state (text input visible).
         */
        function resetInputArea() {
            messageInput.classList.remove('hidden');
            sendButton.classList.remove('hidden');
            emojiButton.classList.remove('hidden');
            recordVoiceButton.classList.remove('hidden');
            attachMediaButtonLabel.classList.remove('hidden'); // Ensure the media attachment button is visible

            stopRecordButton.classList.add('hidden');
            sendVoiceButton.classList.add('hidden');
            recordingStatus.classList.add('hidden');
            
            sendMediaButton.classList.add('hidden'); // Use sendMediaButton
            mediaPreviewStatus.classList.add('hidden'); // Use mediaPreviewStatus
            imageInput.value = ''; // Clear the file input
            selectedMediaBase64 = null;
            selectedMediaMimeType = null;

            setMyTypingStatus(false);
            
            messageArea.scrollTop = messageArea.scrollHeight;
        }

        /**
         * Initializes the chat application after successful authentication.
         */
        function initializeChatApp() {
            passwordScreen.style.display = 'none';
            signupLoginModal.classList.add('hidden');

            chatAppContainer.style.display = 'flex';

            displayUserId.textContent = currentDisplayName;
            myProfilePicThumb.textContent = currentProfilePicUrl; // Set emoji as text content

            setupPresence();
            listenForMessages();
            populateEmojiPicker();
            populateAvatarEmojiPicker(); // NEW: Call to populate avatar emojis
            resetInputArea();
            requestNotificationPermission();
            requestMicrophonePermission();
            
            sendButton.addEventListener('click', sendMessage);
            messageInput.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    sendMessage();
                }
            });

            messageInput.addEventListener('input', () => {
                setMyTypingStatus(true);
                clearTimeout(typingTimeout);
                typingTimeout = setTimeout(() => {
                    setMyTypingStatus(false);
                }, TYPING_INDICATOR_TIMEOUT_MS);
            });

            // New: Handle paste event for Base64 image/GIF from clipboard (e.g., phone keyboard)
            messageInput.addEventListener('paste', handlePasteEvent);

            emojiButton.addEventListener('click', (event) => {
                event.stopPropagation();
                emojiPicker.classList.toggle('hidden');
            });

            document.addEventListener('click', (event) => {
                if (!emojiPicker.contains(event.target) && !emojiButton.contains(event.target)) {
                    emojiPicker.classList.add('hidden');
                }
            });

            recordVoiceButton.addEventListener('click', startRecording);
            stopRecordButton.addEventListener('click', stopRecording);
            sendVoiceButton.addEventListener('click', sendVoiceMessage);

            imageInput.addEventListener('change', handleMediaSelection); // Renamed event listener
            sendMediaButton.addEventListener('click', sendMediaMessage); // Renamed event listener

            onlineUsersIndicator.addEventListener('click', showOnlineUsersModal);
            onlineUsersCloseButton.addEventListener('click', hideOnlineUsersModal);

            leavePrivateChatButton.addEventListener('click', leavePrivateChat);

            messageArea.addEventListener('scroll', updateMyLastReadMessageTimestamp);

            // Profile Modal Event Listeners
            userInfoHeader.addEventListener('click', openProfileModal);
            profileModalCloseButton.addEventListener('click', closeProfileModal);
            profilePicPreview.addEventListener('click', openAvatarSelectionModal); // NEW: Open avatar picker
            saveProfileButton.addEventListener('click', saveProfileSettings);

            // NEW: Avatar Selection Modal Event Listeners
            avatarSelectionCloseButton.addEventListener('click', closeAvatarSelectionModal);
        }

        /**
         * Handles the initial "rexchat" password attempt.
         */
        async function handleSecurityKeyLogin() { 
            if (passwordInput.value === CORRECT_PASSWORD) {
                passwordError.classList.add('hidden');
                passwordScreen.style.display = 'none';
                showSignupLoginModal('login'); // Directly show the signup/login modal
            } else {
                passwordError.classList.remove('hidden');
                passwordError.textContent = "Access Denied. Invalid Key.";
                passwordInput.value = '';
            }
        }
        
        /**
         * Shows the signup/login modal based on the mode.
         * @param {string} mode - 'signup' or 'login'
         */
        function showSignupLoginModal(mode) {
            authMode = mode;
            authErrorMessage.classList.add('hidden');
            authEmailInput.value = '';
            authPasswordInput.value = '';
            authCallsignInput.value = ''; // Clear callsign input too

            if (mode === 'signup') {
                authModalTitle.textContent = 'Create Call-Sign';
                authSubmitButton.textContent = 'Register';
                toggleAuthModeText.textContent = 'Already registered?';
                toggleAuthModeLink.textContent = 'Log In';
                authCallsignInput.classList.remove('hidden'); // Show callsign input for signup
                authCallsignInput.setAttribute('required', 'true');
            } else { // 'login'
                authModalTitle.textContent = 'Retrieve Call-Sign';
                authSubmitButton.textContent = 'Log In';
                toggleAuthModeText.textContent = 'New operative?';
                toggleAuthModeLink.textContent = 'Sign Up';
                authCallsignInput.classList.add('hidden'); // Hide callsign input for login
                authCallsignInput.removeAttribute('required');
            }
            signupLoginModal.classList.remove('hidden');
        }

        /**
         * Toggles between signup and login modes in the modal.
         */
        function toggleAuthMode() {
            showSignupLoginModal(authMode === 'signup' ? 'login' : 'signup');
        }

        /**
         * Handles email/password signup.
         */
        async function handleEmailSignup() {
            const email = authEmailInput.value.trim();
            const password = authPasswordInput.value.trim();
            const callsign = authCallsignInput.value.trim();

            authErrorMessage.classList.add('hidden');

            if (!email || !password || !callsign) {
                authErrorMessage.textContent = "Email, Password, and Callsign cannot be empty.";
                authErrorMessage.classList.remove('hidden');
                return;
            }
            if (password.length < 6) {
                authErrorMessage.textContent = "Password must be at least 6 characters long.";
                authErrorMessage.classList.remove('hidden');
                return;
            }

            try {
                // Check if new callsign is already in use by another user
                const callsignQuery = ref(db, `artifacts/${appId}/public/data/users_presence`);
                const snapshot = await get(callsignQuery);
                let callsignTaken = false;
                snapshot.forEach(childSnapshot => {
                    if (childSnapshot.val().displayName === callsign) {
                        callsignTaken = true;
                    }
                });
                if (callsignTaken) {
                    authErrorMessage.textContent = `Callsign "${callsign}" is already in use. Please choose a different one.`;
                    authErrorMessage.classList.remove('hidden');
                    return;
                }

                let userCredential;
                const currentUser = auth.currentUser;

                // Handle linking anonymous account if user exists and is anonymous
                if (currentUser && currentUser.isAnonymous) {
                    const credential = EmailAuthProvider.credential(email, password);
                    userCredential = await linkWithCredential(currentUser, credential);
                    alertMessage("Anonymous account linked successfully!", 'green');
                } else {
                    userCredential = await createUserWithEmailAndPassword(auth, email, password);
                }

                const user = userCredential.user;
                const currentUserPresenceRef = ref(db, `artifacts/${appId}/public/data/users_presence/${user.uid}`);
                
                // Store the provided callsign, default emoji, and empty custom status
                await set(currentUserPresenceRef, {
                    displayName: callsign,
                    profilePicUrl: currentProfilePicUrl, // Set to the default emoji 'üòÄ'
                    customStatus: '', // Initialize with empty string
                    status: 'online',
                    isTyping: false,
                    typingInChatId: null,
                    lastReadMessageTimestamp: serverTimestamp(),
                    hasUnreadPrivateMessages: false,
                    unreadFrom: {},
                    currentActivePrivateChatWith: null
                });
                localStorage.setItem('chatDisplayName', callsign); // Also save to local storage
                localStorage.setItem('chatProfilePicUrl', currentProfilePicUrl); // Save default emoji
                localStorage.setItem('chatCustomStatus', ''); // Initialize local storage
                alertMessage(`Account created for ${callsign}!`, 'green');

            } catch (error) {
                console.error("Email Signup failed:", error);
                let errorMessage = "Registration failed. Please try again.";
                // Firebase specific error codes
                if (error.code === 'auth/email-already-in-use') {
                    errorMessage = "This email is already registered. Please log in instead.";
                } else if (error.code === 'auth/invalid-email') {
                    errorMessage = "Invalid email address format.";
                } else if (error.code === 'auth/weak-password') {
                    errorMessage = "Password is too weak. Choose a stronger password.";
                }
                authErrorMessage.textContent = errorMessage;
                authErrorMessage.classList.remove('hidden');
            }
        }

        /**
         * Handles email/password login.
         */
        async function handleEmailLogin() {
            const email = authEmailInput.value.trim();
            const password = authPasswordInput.value.trim();
            authErrorMessage.classList.add('hidden');

            if (!email || !password) {
                authErrorMessage.textContent = "Email and Password cannot be empty.";
                authErrorMessage.classList.remove('hidden');
                return;
            }

            try {
                await signInWithEmailAndPassword(auth, email, password);
            } catch (error) {
                console.error("Email Login failed:", error);
                let errorMessage = "Login failed. Invalid credentials.";
                if (error.code === 'auth/invalid-credential' || error.code === 'auth/user-not-found' || error.code === 'auth/wrong-password') {
                    errorMessage = "Invalid email or password.";
                } else if (error.code === 'auth/too-many-requests') {
                    errorMessage = "Too many failed login attempts. Please try again later.";
                }
                authErrorMessage.textContent = errorMessage;
                authErrorMessage.classList.remove('hidden');
            }
        }

        /**
         * Main authentication state observer.
         */
        onAuthStateChanged(auth, async (user) => {
            if (user) {
                currentUserId = user.uid;
                console.log("Firebase Auth State Changed: User is logged in.", user.uid, "Is anonymous:", user.isAnonymous);

                const currentUserPresenceRef = ref(db, `artifacts/${appId}/public/data/users_presence/${currentUserId}`);
                try {
                    const snapshot = await get(currentUserPresenceRef);
                    const userData = snapshot.val();
                    if (userData) {
                        currentDisplayName = userData.displayName || `Unit-${user.uid.substring(0, 4).toUpperCase()}`;
                        // Use default emoji if profilePicUrl is empty string or old placeholder URL
                        currentProfilePicUrl = (userData.profilePicUrl === '' || userData.profilePicUrl === OLD_PLACEHOLDER_URL) ? 'üòÄ' : userData.profilePicUrl || 'üòÄ'; 
                        currentCustomStatus = userData.customStatus || '';

                        localStorage.setItem('chatDisplayName', currentDisplayName);
                        localStorage.setItem('chatProfilePicUrl', currentProfilePicUrl);
                        localStorage.setItem('chatCustomStatus', currentCustomStatus);
                        console.log("Loaded Callsign, Profile Pic, and Custom Status from Firebase:", currentDisplayName, currentProfilePicUrl, currentCustomStatus);
                    } else {
                        // If user data doesn't exist in RTDB (e.g., new login or old anonymous user)
                        currentDisplayName = localStorage.getItem('chatDisplayName') || `Unit-${user.uid.substring(0, 4).toUpperCase()}`;
                        currentProfilePicUrl = localStorage.getItem('chatProfilePicUrl');
                        if (currentProfilePicUrl === null || currentProfilePicUrl === OLD_PLACEHOLDER_URL || currentProfilePicUrl === '') {
                             currentProfilePicUrl = 'üòÄ'; // Default emoji
                        }
                        currentCustomStatus = localStorage.getItem('chatCustomStatus') || '';

                        localStorage.setItem('chatDisplayName', currentDisplayName);
                        localStorage.setItem('chatProfilePicUrl', currentProfilePicUrl);
                        localStorage.setItem('chatCustomStatus', currentCustomStatus);

                        // Ensure presence data is set in Firebase
                        await set(currentUserPresenceRef, {
                            displayName: currentDisplayName,
                            profilePicUrl: currentProfilePicUrl,
                            customStatus: currentCustomStatus,
                            status: 'online',
                            isTyping: false,
                            typingInChatId: null,
                            lastReadMessageTimestamp: serverTimestamp(),
                            hasUnreadPrivateMessages: false,
                            unreadFrom: {},
                            currentActivePrivateChatWith: null
                        });
                        console.log("Initialized/Updated Callsign, Profile Pic, and Custom Status in Firebase:", currentDisplayName, currentProfilePicUrl, currentCustomStatus);
                    }
                    // Initialize tempProfilePicSelection with the current actual profile picture
                    tempProfilePicSelection = currentProfilePicUrl; 

                } catch (error) {
                    console.error("Error fetching user presence data during auth state change:", error);
                    // Fallback to local storage or generate if Firebase fetch fails
                    currentDisplayName = localStorage.getItem('chatDisplayName') || `Unit-${user.uid.substring(0, 4).toUpperCase()}`;
                    currentProfilePicUrl = localStorage.getItem('chatProfilePicUrl');
                    if (currentProfilePicUrl === null || currentProfilePicUrl === OLD_PLACEHOLDER_URL || currentProfilePicUrl === '') {
                        currentProfilePicUrl = 'üòÄ'; // Default emoji
                    }
                    currentCustomStatus = localStorage.getItem('chatCustomStatus') || '';
                    alertMessage("Failed to retrieve profile data. Using local/default.", 'orange');
                    tempProfilePicSelection = currentProfilePicUrl; // Also fallback for temp
                }
                
                initializeChatApp();
            } else {
                console.log("Firebase Auth State Changed: User is logged out.");
                passwordScreen.style.display = 'flex';
                chatAppContainer.style.display = 'none';
                signupLoginModal.classList.add('hidden'); // Hide auth modal if user logs out

                currentUserId = null;
                // currentDisplayName, currentProfilePicUrl, currentCustomStatus are intentionally kept for local consistency until next login/signup
            }
        });


        // Initial event listeners for password screen
        passwordScreen.classList.remove('hidden');
        passwordScreen.style.display = 'flex';
        loginButton.addEventListener('click', handleSecurityKeyLogin);
        passwordInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                handleSecurityKeyLogin();
            }
        });

        // Event listeners for Signup/Login Modal
        signupLoginCloseButton.addEventListener('click', () => {
            signupLoginModal.classList.add('hidden');
            if (!auth.currentUser) { // If user is not authenticated, return to password screen
                 passwordScreen.style.display = 'flex';
            }
        });
        authSubmitButton.addEventListener('click', () => {
            if (authMode === 'signup') {
                handleEmailSignup();
            } else {
                handleEmailLogin();
            }
        });
        authEmailInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                authPasswordInput.focus();
            }
        });
        authPasswordInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                if (authMode === 'signup') {
                    authCallsignInput.focus(); // Move focus to callsign if signing up
                } else {
                    handleEmailLogin(); // Try to log in
                }
            }
        });
        authCallsignInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter' && authMode === 'signup') {
                handleEmailSignup(); // Try to sign up
            }
        });

        toggleAuthModeLink.addEventListener('click', (e) => {
            e.preventDefault();
            toggleAuthMode();
        });


        /**
         * Sets up the Firebase Realtime Database presence system for the current user.
         */
        function setupPresence() {
            if (!currentUserId) {
                console.error("setupPresence called but currentUserId is null. User not authenticated yet.");
                return;
            }

            const connectedRef = ref(db, '.info/connected');
            const currentUserPresenceRef = ref(db, `artifacts/${appId}/public/data/users_presence/${currentUserId}`);

            onValue(connectedRef, (snapshot) => {
                if (snapshot.val() === true) {
                    get(currentUserPresenceRef).then(dataSnapshot => {
                        const existingData = dataSnapshot.val() || {};
                        // Ensure currentProfilePicUrl is updated with the current emoji, not a URL
                        const profilePicToSet = (currentProfilePicUrl === '' || currentProfilePicUrl === OLD_PLACEHOLDER_URL) ? 'üòÄ' : currentProfilePicUrl;

                        set(currentUserPresenceRef, {
                            displayName: currentDisplayName, // Ensure we send the current display name
                            profilePicUrl: profilePicToSet, // Include profile pic URL (emoji)
                            customStatus: currentCustomStatus, // Include custom status
                            status: 'online',
                            isTyping: false,
                            typingInChatId: null,
                            lastReadMessageTimestamp: serverTimestamp(),
                            hasUnreadPrivateMessages: existingData.hasUnreadPrivateMessages || false,
                            unreadFrom: existingData.unreadFrom || {},
                            currentActivePrivateChatWith: currentPrivateChatUserId 
                        });
                    }).catch(e => console.error("Error fetching presence data on connect:", e));

                    onDisconnect(currentUserPresenceRef).set({
                        displayName: currentDisplayName,
                        profilePicUrl: (currentProfilePicUrl === '' || currentProfilePicUrl === OLD_PLACEHOLDER_URL) ? 'üòÄ' : currentProfilePicUrl, // Include profile pic URL (emoji) on disconnect
                        customStatus: currentCustomStatus, // Include custom status on disconnect
                        status: 'offline',
                        isTyping: false,
                        timestamp: serverTimestamp(),
                        typingInChatId: null
                    });
                    myStatusIndicator.classList.remove('offline');
                    myStatusIndicator.classList.add('online');
                } else {
                    myStatusIndicator.classList.remove('online');
                    myStatusIndicator.classList.add('offline');
                }
            });

            onValue(ref(db, `artifacts/${appId}/public/data/users_presence`), (snapshot) => {
                console.log("[setupPresence] Users presence snapshot received.");
                userPresenceMap = {};
                let anyOtherUserTyping = false;
                let onlineUsersCount = 0;
                let totalUnreadPrivateMessages = 0;

                onlineUsersList.innerHTML = '';

                const currentUserData = snapshot.val()?.[currentUserId];
                const currentUserUnreadFrom = currentUserData?.unreadFrom || {};

                let currentActiveChatIdForThisClient = null;
                if (currentPrivateChatUserId) {
                    const ids = [currentUserId, currentPrivateChatUserId].sort();
                    currentActiveChatIdForThisClient = `${ids[0]}_${ids[1]}`;
                } else {
                    currentActiveChatIdForThisClient = "public";
                }

                snapshot.forEach((childSnapshot) => {
                    const userData = childSnapshot.val();
                    const userId = childSnapshot.key;
                    
                    // Filter out old placeholder URLs from received data too
                    const userProfilePic = (userData.profilePicUrl === '' || userData.profilePicUrl === OLD_PLACEHOLDER_URL) ? 'üòÄ' : userData.profilePicUrl || 'üòÄ';
                    userPresenceMap[userId] = { ...userData, profilePicUrl: userProfilePic };

                    if (userData.status === 'online') {
                        onlineUsersCount++;

                        const listItem = document.createElement('li');
                        listItem.dataset.userId = userId;
                        listItem.dataset.displayName = userData.displayName;
                        
                        // For online user list, use a span for emoji
                        const profilePicSpan = document.createElement('span');
                        profilePicSpan.classList.add('profile-pic-thumbnail', 'mr-2', 'flex', 'items-center', 'justify-center');
                        profilePicSpan.textContent = userProfilePic; // Display emoji
                        profilePicSpan.alt = 'A'; // Alt text for accessibility
                        listItem.appendChild(profilePicSpan);

                        const textSpan = document.createElement('span');
                        textSpan.textContent = userData.displayName || `Unit-${userId.substring(0, 4).toUpperCase()}...`;
                        if (userData.customStatus) {
                            textSpan.textContent += ` (${userData.customStatus})`;
                        }
                        listItem.appendChild(textSpan);

                        const hasUnreadFromThisUser = currentUserUnreadFrom[userId];

                        if (userId !== currentUserId && hasUnreadFromThisUser) {
                            const pmDot = document.createElement('span');
                            pmDot.classList.add('pm-notification-dot');
                            listItem.appendChild(pmDot);
                            totalUnreadPrivateMessages++;
                        }

                        if (userId === currentUserId) {
                            listItem.classList.add('bg-green-800', 'border-green-600');
                            textSpan.textContent += ' (You)';
                        } else {
                            listItem.addEventListener('click', () => startPrivateChat(userId, userData.displayName));
                        }
                        onlineUsersList.appendChild(listItem);
                        
                        if (userId !== currentUserId && userData.typingInChatId === currentActiveChatIdForThisClient) {
                            anyOtherUserTyping = true;
                        }
                    }
                });
                onlineCountSpan.textContent = onlineUsersCount;
                
                if (pmNotificationBadge) {
                    if (totalUnreadPrivateMessages > 0) {
                        pmNotificationBadge.classList.remove('hidden');
                    } else {
                        pmNotificationBadge.classList.add('hidden');
                    }
                }

                updateAllMessageStatusesInUI();

                const typingIndicatorElement = document.getElementById('typing-indicator');
                if (typingIndicatorElement) {
                    if (anyOtherUserTyping) {
                        typingIndicatorElement.classList.remove('hidden');
                        messageArea.scrollTop = messageArea.scrollHeight;
                    } else {
                        typingIndicatorElement.classList.add('hidden');
                    }
                }
            });
        }

        /**
         * Sets the current user's typing status in Firebase.
         * @param {boolean} isTyping - True if typing, false otherwise.
         */
        function setMyTypingStatus(isTyping) {
            if (!currentUserId) {
                console.warn("Cannot set typing status: currentUserId is null. User not authenticated.");
                return;
            }

            const currentUserPresenceRef = ref(db, `artifacts/${appId}/public/data/users_presence/${currentUserId}`);
            let typingStatusChatId = null;

            if (isTyping) {
                if (currentPrivateChatUserId) {
                    const ids = [currentUserId, currentPrivateChatUserId].sort();
                    typingStatusChatId = `${ids[0]}_${ids[1]}`;
                } else {
                    typingStatusChatId = "public";
                }
            }

            get(currentUserPresenceRef).then(snapshot => {
                const currentData = snapshot.val() || {};
                const profilePicToSet = (currentProfilePicUrl === '' || currentProfilePicUrl === OLD_PLACEHOLDER_URL) ? 'üòÄ' : currentProfilePicUrl;

                set(currentUserPresenceRef, {
                    ...currentData,
                    displayName: currentDisplayName,
                    profilePicUrl: profilePicToSet, // Ensure profile pic (emoji) is sent
                    customStatus: currentCustomStatus, // Ensure custom status is sent
                    status: 'online',
                    isTyping: isTyping,
                    typingInChatId: typingStatusChatId,
                    timestamp: serverTimestamp(),
                    currentActivePrivateChatWith: currentPrivateChatUserId 
                });
            }).catch(error => console.error("Error setting typing status:", error));
        }

        /**
         * Updates the current user's last read message timestamp.
         */
        function updateMyLastReadMessageTimestamp() {
            if (!currentUserId) {
                console.warn("Cannot update last read timestamp: currentUserId is null. User not authenticated.");
                return;
            }

            const tolerance = 50;
            if (messageArea.scrollHeight - messageArea.scrollTop <= messageArea.clientHeight + tolerance) {
                const allMessageElements = messageArea.querySelectorAll('.mb-3');
                const lastMessageElement = allMessageElements.length > 0 ? allMessageElements[allMessageElements.length - 1] : null;

                if (lastMessageElement && lastMessageElement.dataset.timestamp) {
                    const lastMessageTimestamp = parseInt(lastMessageElement.dataset.timestamp);
                    const currentUserPresenceRef = ref(db, `artifacts/${appId}/public/data/users_presence/${currentUserId}`);
                    if (!userPresenceMap[currentUserId] || userPresenceMap[currentUserId].lastReadMessageTimestamp < lastMessageTimestamp) {
                        get(currentUserPresenceRef).then(snapshot => {
                            const currentData = snapshot.val() || {};
                            set(currentUserPresenceRef, {
                                ...currentData,
                                lastReadMessageTimestamp: lastMessageTimestamp,
                                timestamp: serverTimestamp(),
                                currentActivePrivateChatWith: currentPrivateChatUserId 
                            });
                        }).catch(error => console.error("Error updating last read timestamp:", error));
                    }
                }
            }
        }


        /**
         * Updates the status indicator for all messages in the UI based on userPresenceMap.
         */
        function updateAllMessageStatusesInUI() {
            document.querySelectorAll('.status-indicator').forEach(indicator => {
                const userId = indicator.dataset.userId;
                const userStatus = userPresenceMap[userId] ? userPresenceMap[userId].status : 'unknown';

                indicator.textContent = userStatus === 'online' ? '[ONLINE]' : '[OFFLINE]';
                indicator.classList.remove('online', 'offline');
                if (userStatus === 'online') {
                    indicator.classList.add('online');
                    indicator.style.color = '#10b981';
                } else {
                    indicator.classList.add('offline');
                    indicator.style.color = '#ef4444';
                }
            });

            // Update profile pictures (emojis) in message bubbles
            document.querySelectorAll('.profile-pic-thumbnail[data-user-id]').forEach(spanElement => {
                const userId = spanElement.dataset.userId;
                // Filter out old placeholder URLs from userPresenceMap
                const userPicUrl = userPresenceMap[userId] ? ((userPresenceMap[userId].profilePicUrl === '' || userPresenceMap[userId].profilePicUrl === OLD_PLACEHOLDER_URL) ? 'üòÄ' : userPresenceMap[userId].profilePicUrl) : 'üòÄ';
                spanElement.textContent = userPicUrl; // Display emoji
            });

            document.querySelectorAll('.my-message-seen-status').forEach(seenStatusDiv => {
                const messageElement = seenStatusDiv.closest('.mb-3');
                if (!messageElement) return;

                const messageTimestamp = parseInt(messageElement.dataset.timestamp);
                const seenBy = [];
                for (const userId in userPresenceMap) {
                    if (userId !== currentUserId && userPresenceMap[userId].status === 'online' &&
                        userPresenceMap[userId].lastReadMessageTimestamp &&
                        userPresenceMap[userId].lastReadMessageTimestamp >= messageTimestamp) {
                        seenBy.push(userPresenceMap[userId].displayName || `Unit-${userId.substring(0,4).toUpperCase()}`);
                    }
                }

                if (seenBy.length > 0) {
                    seenStatusDiv.textContent = `Seen by: ${seenBy.join(', ')}`;
                    seenStatusDiv.classList.remove('hidden');
                } else {
                    seenStatusDiv.classList.add('hidden');
                }
            });
        }

        /**
         * Shows the online users modal.
         */
        function showOnlineUsersModal() {
            onlineUsersModal.classList.remove('hidden');
        }

        /**
         * Hides the online users modal.
         */
        function hideOnlineUsersModal() {
            onlineUsersModal.classList.add('hidden');
        }

        /**
         * Opens the profile management modal.
         */
        function openProfileModal() {
            profileModal.classList.remove('hidden');
            // Show the currently selected temporary avatar in the preview
            profilePicPreview.textContent = tempProfilePicSelection; 
            profileCallsignInput.value = currentDisplayName;
            profileCustomStatusInput.value = currentCustomStatus;
            profileErrorMessage.classList.add('hidden');
        }

        /**
         * Closes the profile management modal.
         */
        function closeProfileModal() {
            profileModal.classList.add('hidden');
            // Reset tempProfilePicSelection to the currently saved currentProfilePicUrl if not saved
            tempProfilePicSelection = currentProfilePicUrl; 
        }

        /**
         * NEW: Opens the avatar selection modal.
         */
        function openAvatarSelectionModal() {
            avatarSelectionModal.classList.remove('hidden');
            populateAvatarEmojiPicker(); // Ensure picker is populated and selection is highlighted
        }

        /**
         * NEW: Closes the avatar selection modal.
         */
        function closeAvatarSelectionModal() {
            avatarSelectionModal.classList.add('hidden');
        }

        /**
         * Populates the avatar emoji picker (now in its own modal).
         */
        function populateAvatarEmojiPicker() {
            avatarEmojiPicker.innerHTML = '';
            avatarEmojis.forEach(emoji => {
                const button = document.createElement('button');
                button.textContent = emoji;
                button.title = `Select ${emoji}`;
                // Highlight the button if it matches the temporary selection
                if (emoji === tempProfilePicSelection) {
                    button.classList.add('selected');
                }
                button.addEventListener('click', () => {
                    // Update only the temporary selection and the preview in the main profile modal
                    tempProfilePicSelection = emoji; 
                    profilePicPreview.textContent = tempProfilePicSelection; 
                    // Update visual selection in the avatar picker modal itself
                    document.querySelectorAll('.avatar-emoji-picker button').forEach(btn => btn.classList.remove('selected'));
                    button.classList.add('selected');
                    // Automatically close this modal after selection for better UX
                    closeAvatarSelectionModal(); 
                    alertMessage(`Avatar selected (unsaved): ${emoji}!`, 'blue');
                });
                avatarEmojiPicker.appendChild(button);
            });
        }

        /**
         * Saves profile settings (callsign and custom status, and selected avatar emoji) to Firebase.
         */
        async function saveProfileSettings() {
            if (!currentUserId) {
                alertMessage("Authentication required to save profile.", 'red');
                return;
            }

            const newCallsign = profileCallsignInput.value.trim();
            const newCustomStatus = profileCustomStatusInput.value.trim();
            profileErrorMessage.classList.add('hidden');

            if (!newCallsign) {
                profileErrorMessage.textContent = "Callsign cannot be empty.";
                profileErrorMessage.classList.remove('hidden');
                return;
            }

            const currentUserPresenceRef = ref(db, `artifacts/${appId}/public/data/users_presence/${currentUserId}`);
            
            try {
                // Check if new callsign is already in use by another user
                if (newCallsign !== currentDisplayName) {
                    const callsignQuery = ref(db, `artifacts/${appId}/public/data/users_presence`);
                    const snapshot = await get(callsignQuery);
                    let callsignTaken = false;
                    snapshot.forEach(childSnapshot => {
                        if (childSnapshot.val().displayName === newCallsign && childSnapshot.key !== currentUserId) {
                            callsignTaken = true;
                        }
                    });
                    if (callsignTaken) {
                        profileErrorMessage.textContent = `Callsign "${newCallsign}" is already in use.`;
                        profileErrorMessage.classList.remove('hidden');
                        return;
                    }
                }
                // Ensure the saved profilePicUrl is always an emoji and not the old placeholder URL
                const profilePicToSave = (tempProfilePicSelection === '' || tempProfilePicSelection === OLD_PLACEHOLDER_URL) ? 'üòÄ' : tempProfilePicSelection;

                await update(currentUserPresenceRef, {
                    displayName: newCallsign,
                    customStatus: newCustomStatus,
                    profilePicUrl: profilePicToSave // Save the selected emoji from temp
                });

                currentDisplayName = newCallsign;
                currentCustomStatus = newCustomStatus;
                currentProfilePicUrl = profilePicToSave; // Update main state after successful save
                localStorage.setItem('chatDisplayName', newCallsign);
                localStorage.setItem('chatCustomStatus', newCustomStatus);
                localStorage.setItem('chatProfilePicUrl', currentProfilePicUrl); // Save the selected emoji

                displayUserId.textContent = currentDisplayName; // Update header
                myProfilePicThumb.textContent = currentProfilePicUrl; // Update thumbnail in header
                alertMessage("Profile saved successfully!", 'green');
                closeProfileModal(); // Close profile modal
            } catch (error) {
                console.error("Error saving profile:", error);
                profileErrorMessage.textContent = `Failed to save profile: ${error.message}`;
                profileErrorMessage.classList.remove('hidden');
            }
        }


        /**
         * Initiates a private chat with a selected user.
         * @param {string} targetUserId - The Firebase User ID of the chat partner.
         * @param {string} targetDisplayName - The display name of the chat partner.
         */
        function startPrivateChat(targetUserId, targetDisplayName) {
            console.log(`[startPrivateChat] Starting private chat with ${targetDisplayName} (${targetUserId})`);
            currentPrivateChatUserId = targetUserId;
            currentPrivateChatDisplayName = targetDisplayName;

            currentChatTitle.textContent = `Private Comms with ${targetDisplayName}`;
            leavePrivateChatButton.classList.remove('hidden');
            hideOnlineUsersModal();

            const currentUserPresenceRef = ref(db, `artifacts/${appId}/public/data/users_presence/${currentUserId}`);
            update(currentUserPresenceRef, { currentActivePrivateChatWith: targetUserId })
                .then(() => console.log(`[startPrivateChat] Current user presence updated: in private chat with ${targetUserId}.`))
                .catch(e => console.error("[startPrivateChat] Error updating currentActivePrivateChatWith:", e));

            const currentUserUnreadFromSpecificRef = ref(db, `artifacts/${appId}/public/data/users_presence/${currentUserId}/unreadFrom/${targetUserId}`);
            remove(currentUserUnreadFromSpecificRef).then(() => {
                console.log(`[startPrivateChat] Marked unread messages from ${targetDisplayName} as read for ${currentUserId}.`);
                const currentUserUnreadFromRootRef = ref(db, `artifacts/${appId}/public/data/users_presence/${currentUserId}/unreadFrom`);
                get(currentUserUnreadFromRootRef).then(snapshot => {
                    if (!snapshot.exists() || Object.keys(snapshot.val()).length === 0) {
                        const currentUserPresenceRootRef = ref(db, `artifacts/${appId}/public/data/users_presence/${currentUserId}`);
                        update(currentUserPresenceRootRef, { hasUnreadPrivateMessages: false })
                            .then(() => console.log(`[startPrivateChat] hasUnreadPrivateMessages set to false for ${currentUserId}.`))
                            .catch(e => console.error("[startPrivateChat] Error updating hasUnreadPrivateMessages to false:", e));
                    }
                }).catch(e => console.error("[startPrivateChat] Error checking unreadFrom for global badge:", e));
            }).catch(e => console.error("[startPrivateChat] Error removing unreadFrom flag:", e));


            messageArea.innerHTML = `<div id="loading-indicator" class="text-center text-gray-500 mt-8 text-sm md:text-base">Establishing Private Channel...</div>
                                    <div id="typing-indicator" class="typing-indicator hidden">
                                    <span style="--delay: 0s;">.</span><span style="--delay: 0.2s;">.</span><span style="--delay: 0.4s;">.</span> Someone is typing...
                                    </div>`;

            listenForMessages();

            alertMessage(`Initiating private comms with ${targetDisplayName}`, 'blue');
            messageArea.scrollTop = messageArea.scrollHeight;
        }

        /**
         * Leaves the current private chat and returns to the public channel.
         */
        function leavePrivateChat() {
            console.log("[leavePrivateChat] Exiting private chat. Resetting state.");
            currentPrivateChatUserId = null;
            currentPrivateChatDisplayName = null;

            currentChatTitle.textContent = 'Public Channel';
            leavePrivateChatButton.classList.add('hidden');

            const currentUserPresenceRef = ref(db, `artifacts/${appId}/public/data/users_presence/${currentUserId}`);
            update(currentUserPresenceRef, { currentActivePrivateChatWith: null })
                .then(() => console.log(`[leavePrivateChat] Current user presence updated: back to public channel.`))
                .catch(e => console.error("[leavePrivateChat] Error updating currentActivePrivateChatWith to null:", e));

            messageArea.innerHTML = `<div id="loading-indicator" class="text-center text-gray-500 mt-8 text-sm md:text-base">Re-establishing Public Channel...</div>
                                    <div id="typing-indicator" class="typing-indicator hidden">
                                    <span style="--delay: 0s;">.</span><span style="--delay: 0.2s;">.</span><span style="--delay: 0.4s;">.</span> Someone is typing...
                                    </div>`;
            messageArea.scrollTop = messageArea.scrollHeight;

            listenForMessages(); 

            alertMessage("Returned to public comms channel.", 'blue');
        }


        // Array of common emojis (renamed to 'protocol_icons' for military theme)
        const protocol_icons = [
            'üëç', '‚úÖ', '‚ùå', '‚ö†Ô∏è', 'üö®', 'üìç', 'üó∫Ô∏è', 'üì°', '‚öôÔ∏è', 'üõ°Ô∏è',
            '‚¨ÜÔ∏è', '‚¨áÔ∏è', '‚¨ÖÔ∏è', '‚û°Ô∏è', 'üßä', 'üî•', 'üíß', 'üí®', '‚òÄÔ∏è', '‚òÅÔ∏è', 'üåßÔ∏è', '‚ùÑÔ∏è',
            'üéØ', 'üí£', 'üö©', 'üí°', 'üí¨', 'üé∂', 'üîá', 'üîà', 'üîä', 'üî¨',
            'üîé', 'üîë', 'üîó', 'üîí', 'üîì',
            'üìä', 'üìà', 'üìâ', 'üìä', 'üìù'
        ];

        /**
         * Populates the emoji picker with buttons for each emoji.
         */
        function populateEmojiPicker() {
            emojiPicker.innerHTML = '';
            protocol_icons.forEach(emoji => {
                const button = document.createElement('button');
                button.textContent = emoji;
                button.title = emoji;
                button.addEventListener('click', () => {
                    messageInput.value += emoji;
                    emojiPicker.classList.add('hidden');
                    messageInput.focus();
                });
                emojiPicker.appendChild(button);
            });
        }

        /**
         * Cleans up old messages, retaining only the latest 30.
         */
        async function cleanupOldMessages() {
            const messagesRef = ref(db, `artifacts/${appId}/public/data/messages`); 
            try {
                const snapshot = await get(query(messagesRef, orderByChild('timestamp')));
                
                if (snapshot.exists()) {
                    const messagesToDelete = [];
                    const messagesArray = [];

                    snapshot.forEach(childSnapshot => {
                        messagesArray.push({ id: childSnapshot.key, ...childSnapshot.val() });
                    });

                    messagesArray.sort((a, b) => (a.timestamp || 0) - (b.timestamp || 0));

                    if (messagesArray.length > 30) {
                        for (let i = 0; i < messagesArray.length - 30; i++) {
                            messagesToDelete.push(messagesArray[i].id);
                        }

                        const deletePromises = messagesToDelete.map(msgId => {
                            return remove(child(messagesRef, msgId));
                        });
                        await Promise.all(deletePromises);
                        console.log(`Cleaned up ${messagesToDelete.length} old public messages.`);
                    }
                }
            } catch (error) {
                console.error("Error cleaning up old messages:", error);
            }
        }


        /**
         * Sends a message to the Firebase Realtime Database.
         * This function now handles text, audio, and image/GIF messages.
         */
        async function sendMessage() {
            if (!currentUserId) {
                alertMessage("Authentication required to send messages. Please log in or sign up.", 'red');
                return;
            }

            const messageText = messageInput.value.trim();
            let messagesPath = '';

            if (currentPrivateChatUserId) {
                const chatPartnerId = currentPrivateChatUserId;
                const ids = [currentUserId, chatPartnerId].sort();
                const chatId = `${ids[0]}_${ids[1]}`;
                messagesPath = `artifacts/${appId}/private_chats/${chatId}/messages`;
            } else {
                messagesPath = `artifacts/${appId}/public/data/messages`;
            }

            if ((messageText || audioBlob || selectedMediaBase64) && currentUserId) {
                try {
                    const messagesRef = ref(db, messagesPath);
                    const messagePayload = {
                        userId: currentUserId,
                        displayName: currentDisplayName,
                        profilePicUrl: (currentProfilePicUrl === '' || currentProfilePicUrl === OLD_PLACEHOLDER_URL) ? 'üòÄ' : currentProfilePicUrl, // Include sender's profile picture URL (emoji)
                        timestamp: serverTimestamp(),
                    };

                    if (messageText) {
                        messagePayload.text = messageText;
                        messagePayload.type = 'text';
                    } else if (audioBlob) {
                        const reader = new FileReader();
                        reader.onloadend = async () => {
                            messagePayload.audioData = reader.result;
                            messagePayload.audioMimeType = audioMimeType;
                            messagePayload.type = 'audio';
                            await push(messagesRef, messagePayload);

                            if (currentPrivateChatUserId) {
                                const recipientPresenceRef = ref(db, `artifacts/${appId}/public/data/users_presence/${currentPrivateChatUserId}`);
                                get(recipientPresenceRef).then(recipientSnapshot => {
                                    const recipientData = recipientSnapshot.val();
                                    const isRecipientCurrentlyChattingWithMe = recipientData && recipientData.currentActivePrivateChatWith === currentUserId;

                                    if (!isRecipientCurrentlyChattingWithMe) {
                                        update(recipientPresenceRef, {
                                            hasUnreadPrivateMessages: true,
                                            [`unreadFrom/${currentUserId}`]: true
                                        }).catch(e => console.error("Error setting unread PM flag on recipient:", e));
                                    }
                                }).catch(e => console.error("Error fetching recipient presence for unread check:", e));
                            }

                            audioBlob = null;
                            audioChunks = [];
                            audioMimeType = '';
                            resetInputArea();
                            if (!currentPrivateChatUserId) {
                                cleanupOldMessages(); 
                            }
                        };
                        reader.readAsDataURL(audioBlob);
                        return;
                    } else if (selectedMediaBase64) { // This now handles both images and GIFs
                        messagePayload.imageData = selectedMediaBase64;
                        messagePayload.imageMimeType = selectedMediaMimeType;
                        // Determine type based on mimeType
                        if (selectedMediaMimeType === 'image/gif') {
                            messagePayload.type = 'gif';
                        } else {
                            messagePayload.type = 'image';
                        }
                    }

                    await push(messagesRef, messagePayload);

                    if (currentPrivateChatUserId) {
                        const recipientPresenceRef = ref(db, `artifacts/${appId}/public/data/users_presence/${currentPrivateChatUserId}`);
                        get(recipientPresenceRef).then(recipientSnapshot => {
                            const recipientData = recipientSnapshot.val();
                            const isRecipientCurrentlyChattingWithMe = recipientData && recipientData.currentActivePrivateChatWith === currentUserId;

                            if (!isRecipientCurrentlyChattingWithMe) {
                                update(recipientPresenceRef, {
                                    hasUnreadPrivateMessages: true,
                                    [`unreadFrom/${currentUserId}`]: true
                                }).catch(e => console.error("Error setting unread PM flag on recipient:", e));
                            }
                        }).catch(e => console.error("Error fetching recipient presence for unread check:", e));
                    }

                } catch (error) {
                    console.error("Error sending message:", error);
                    alertMessage("Transmission failed. Retrying...", 'red');
                } finally {
                    if (!audioBlob) { // Ensure resetInputArea is called if it's not an audio message being sent (audio message handles its own reset via reader.onloadend)
                        messageInput.value = '';
                        resetInputArea();
                        if (!currentPrivateChatUserId) {
                            cleanupOldMessages(); 
                        }
                    }
                }
            } else {
                alertMessage("No content to transmit.", 'red');
                resetInputArea();
            }
        }

        /**
         * Starts recording audio.
         */
        async function startRecording() {
            if (!currentUserId) {
                alertMessage("Authentication required to record messages. Please log in or sign up.", 'red');
                return;
            }

            try {
                const permissionStatus = await navigator.permissions.query({ name: 'microphone' });
                if (permissionStatus.state === 'denied') {
                    alertMessage("Microphone access denied. Please enable it in your browser settings to record audio.", 'red');
                    return;
                }

                const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                const options = { mimeType: 'audio/webm' };
                if (!MediaRecorder.isTypeSupported(options.mimeType)) {
                    options.mimeType = 'audio/ogg';
                    if (!MediaRecorder.isTypeSupported(options.mimeType)) {
                        options.mimeType = 'audio/wav';
                        if (!MediaRecorder.isTypeSupported(options.mimeType)) {
                            alertMessage("Audio recording not supported in this browser.", 'red');
                            return;
                        }
                    }
                }
                
                mediaRecorder = new MediaRecorder(stream, options);
                audioMimeType = options.mimeType;
                audioChunks = [];

                mediaRecorder.ondataavailable = event => {
                    audioChunks.push(event.data);
                };

                mediaRecorder.onstop = () => {
                    audioBlob = new Blob(audioChunks, { type: audioMimeType });
                    // No need to hide buttons here, mediaRecorder.onstop fires *after* we've prepared for sending or cancelled
                    // Visibility will be handled by resetInputArea after send, or user can manually reset
                };

                mediaRecorder.start();
                recordVoiceButton.classList.add('record-button-active');
                
                // Hide other input options when recording starts
                recordVoiceButton.classList.add('hidden'); // Hide self
                stopRecordButton.classList.remove('hidden'); // Show stop button
                recordingStatus.classList.remove('hidden'); // Show recording status
                
                sendVoiceButton.classList.add('hidden'); // Keep send hidden until recording stops
                messageInput.classList.add('hidden');
                sendButton.classList.add('hidden');
                emojiButton.classList.add('hidden');
                attachMediaButtonLabel.classList.add('hidden'); // Hide the media attachment button
                sendMediaButton.classList.add('hidden');
                mediaPreviewStatus.classList.add('hidden');

                setMyTypingStatus(false);
                alertMessage("Audio log initiated...", 'blue');

            } catch (err) {
                console.error("Error accessing microphone:", err);
                alertMessage("Failed to access microphone. Check if a microphone is connected.", 'red');
                resetInputArea(); // Reset everything if recording fails
            }
        }

        /**
         * Stops recording audio.
         */
        function stopRecording() {
            if (mediaRecorder && mediaRecorder.state !== 'inactive') {
                mediaRecorder.stop();
                mediaRecorder.stream.getTracks().forEach(track => track.stop());
                // Show send button and hide stop button
                stopRecordButton.classList.add('hidden');
                sendVoiceButton.classList.remove('hidden');
                recordingStatus.classList.add('hidden'); // Hide recording status
                recordVoiceButton.classList.remove('record-button-active'); // Remove animation
                alertMessage("Audio log terminated. Ready for transmit.", 'blue');
            }
        }

        /**
         * Sends a voice message to the Firebase Realtime Database.
         */
        async function sendVoiceMessage() {
            if (audioBlob && currentUserId) {
                sendMessage();
            } else {
                alertMessage("No audio log detected for transmission.", 'red');
                resetInputArea();
            }
        }

        /**
         * Handles image/GIF file selection.
         * @param {Event} event - The change event from the file input.
         */
        function handleMediaSelection(event) {
            if (!currentUserId) {
                alertMessage("Authentication required to send media. Please log in or sign up.", 'red');
                imageInput.value = ''; // Clear input if no auth
                return;
            }

            const file = event.target.files[0];
            if (file) {
                if (!file.type.startsWith('image/')) {
                    alertMessage("Please select an image or GIF file.", 'red');
                    imageInput.value = '';
                    selectedMediaBase64 = null;
                    selectedMediaMimeType = null;
                    resetInputArea();
                    return;
                }

                const reader = new FileReader();
                reader.onloadend = () => {
                    selectedMediaBase64 = reader.result;
                    selectedMediaMimeType = file.type;

                    // Hide unrelated controls
                    messageInput.classList.add('hidden');
                    sendButton.classList.add('hidden');
                    recordVoiceButton.classList.add('hidden');
                    stopRecordButton.classList.add('hidden');
                    sendVoiceButton.classList.add('hidden');
                    recordingStatus.classList.add('hidden');
                    emojiButton.classList.add('hidden');
                    // attachMediaButtonLabel.classList.add('hidden'); // DO NOT HIDE the label, it's the trigger for file input

                    // Show media-specific controls
                    sendMediaButton.classList.remove('hidden');
                    mediaPreviewStatus.classList.remove('hidden');
                    
                    setMyTypingStatus(false);
                    alertMessage(`Media selected (${file.type}), ready for transmission.`, 'blue');
                };
                reader.readAsDataURL(file);
            } else {
                selectedMediaBase64 = null;
                selectedMediaMimeType = null;
                resetInputArea(); // Reset if file selection is cancelled
            }
        }

        /**
         * Handles paste events on the message input to detect Base64 images/GIFs.
         * @param {Event} event - The paste event.
         */
        function handlePasteEvent(event) {
            const clipboardData = event.clipboardData || window.clipboardData;
            const pastedText = clipboardData.getData('text/plain');

            // Regex to check for a data URI (Base64 encoded image/gif)
            const dataURIRegex = /^data:image\/(png|jpeg|gif|webp);base64,([A-Za-z0-9+/=]+)$/;
            const match = pastedText.match(dataURIRegex);

            if (match) {
                event.preventDefault(); // Prevent the Base64 string from appearing in the input
                selectedMediaBase64 = pastedText;
                selectedMediaMimeType = match[0].split(';')[0].split(':')[1]; // e.g., "image/gif"
                
                // Simulate file selection flow
                messageInput.value = ''; // Clear input
                messageInput.classList.add('hidden');
                sendButton.classList.add('hidden');
                recordVoiceButton.classList.add('hidden');
                stopRecordButton.classList.add('hidden');
                sendVoiceButton.classList.add('hidden');
                recordingStatus.classList.add('hidden');
                emojiButton.classList.add('hidden');
                // attachMediaButtonLabel.classList.add('hidden'); // Keep visible for manual file upload

                sendMediaButton.classList.remove('hidden');
                mediaPreviewStatus.textContent = `Pasted ${selectedMediaMimeType.split('/')[1].toUpperCase()} ready...`;
                mediaPreviewStatus.classList.remove('hidden');
                
                setMyTypingStatus(false);
                alertMessage(`Pasted ${selectedMediaMimeType.split('/')[1].toUpperCase()} detected. Ready for transmit.`, 'blue');
            } else {
                // If it's not a Base64 image, let the text paste normally
                console.log("Pasted content is not a Base64 image/GIF.");
            }
        }


        /**
         * Sends an image or GIF message to the Firebase Realtime Database.
         */
        async function sendMediaMessage() {
            if (selectedMediaBase64 && currentUserId) {
                sendMessage();
            } else {
                alertMessage("No media detected for transmission.", 'red');
                resetInputArea();
            }
        }


        /**
         * Listens for new messages from the Firebase Realtime Database in real-time.
         */
        let publicMessageUnsubscribe = null;
        let privateMessageUnsubscribe = null;

        function listenForMessages() {
            if (publicMessageUnsubscribe) {
                publicMessageUnsubscribe();
                publicMessageUnsubscribe = null;
                console.log("[listenForMessages] Unsubscribed from public messages.");
            }
            if (privateMessageUnsubscribe) {
                privateMessageUnsubscribe();
                privateMessageUnsubscribe = null;
                console.log("[listenForMessages] Unsubscribed from private messages.");
            }

            let messagesRef;
            if (currentPrivateChatUserId) {
                const ids = [currentUserId, currentPrivateChatUserId].sort();
                const chatId = `${ids[0]}_${ids[1]}`;
                messagesRef = ref(db, `artifacts/${appId}/private_chats/${chatId}/messages`);
                console.log(`[listenForMessages] Actively listening to private chat: ${messagesRef.toString()}`);
            } else {
                messagesRef = ref(db, `artifacts/${appId}/public/data/messages`);
                console.log(`[listenForMessages] Actively listening to public chat: ${messagesRef.toString()}`);
            }

            const unsubscribe = onValue(messagesRef, (snapshot) => {
                const currentLoadingIndicator = document.getElementById('loading-indicator');
                const currentTypingIndicator = document.getElementById('typing-indicator');

                if (currentLoadingIndicator) {
                    currentLoadingIndicator.style.display = 'none';
                }
                
                Array.from(messageArea.children).forEach(child => {
                    if (child !== currentLoadingIndicator && child !== currentTypingIndicator) {
                        child.remove();
                    }
                });

                let currentLastMessageTimestamp = 0;

                if (snapshot.exists()) {
                    const messagesData = snapshot.val();
                    const messagesArray = [];

                    for (const key in messagesData) {
                        messagesArray.push({ id: key, ...messagesData[key] });
                    }
                    messagesArray.sort((a, b) => (a.timestamp || 0) - (b.timestamp || 0));

                    messagesArray.forEach(msg => {
                        const messageElement = document.createElement('div');
                        let alignmentClass = '';
                        let bubbleColorClass = '';
                        let textColorClass = 'text-gray-200';

                        const senderName = msg.displayName || `Unit-${msg.userId.substring(0, 4).toUpperCase()}...`;
                        const senderColorClass = (msg.userId === currentUserId) ? 'text-green-400' : 'text-blue-400';
                        // Get sender's profile picture (emoji) from userPresenceMap, or fall back to message's picUrl, or default
                        const senderProfilePicUrl = userPresenceMap[msg.userId] ? ((userPresenceMap[msg.userId].profilePicUrl === '' || userPresenceMap[msg.userId].profilePicUrl === OLD_PLACEHOLDER_URL) ? 'üòÄ' : userPresenceMap[msg.userId].profilePicUrl) : ((msg.profilePicUrl === '' || msg.profilePicUrl === OLD_PLACEHOLDER_URL) ? 'üòÄ' : msg.profilePicUrl || 'üòÄ');


                        if (msg.userId === currentUserId) {
                            alignmentClass = 'flex justify-end';
                            bubbleColorClass = 'bg-gray-700 border border-green-600';
                        } else {
                            alignmentClass = 'flex justify-start';
                            bubbleColorClass = 'bg-gray-800 border border-blue-600';
                        }

                        const date = msg.timestamp ? new Date(msg.timestamp) : null;
                        const timeString = date ? date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }) : 'Processing...';

                        let contentHtml = '';
                        if (msg.audioData) {
                            contentHtml = `
                                <audio controls class="w-full mt-2 rounded-md bg-gray-600 outline-none focus:outline-none focus:ring-1 focus:ring-green-400">
                                    <source src="${msg.audioData}" type="${msg.audioMimeType || 'audio/webm'}">
                                    Your browser does not support the audio element.
                                </audio>
                            `;
                            let voiceMessageLabel = msg.userId === currentUserId ? "AUDIO LOG (OUTGOING)" : "AUDIO LOG (INCOMING)";
                            contentHtml = `<div class="font-semibold mb-1 text-xs uppercase tracking-wide ${senderColorClass}">${voiceMessageLabel}</div>` + contentHtml;
                        } else if (msg.type === 'image' || msg.type === 'gif') { // Handle both image and gif
                            const mediaTypeLabel = msg.type === 'gif' ? "GIF LOG" : "IMAGE LOG";
                            contentHtml = `
                                <img src="${msg.imageData}" alt="User ${mediaTypeLabel}" class="max-w-full h-auto rounded-md mt-2 border border-gray-600 object-contain" style="max-height: 200px;">
                            `;
                            let imageMessageLabel = msg.userId === currentUserId ? `${mediaTypeLabel} (OUTGOING)` : `${mediaTypeLabel} (INCOMING)`;
                            contentHtml = `<div class="font-semibold mb-1 text-xs uppercase tracking-wide ${senderColorClass}">${imageMessageLabel}</div>` + contentHtml;
                        }
                        else {
                            let messageText = msg.text;
                            contentHtml = `<div class="text-sm md:text-base ${textColorClass} tracking-tight">${messageText}</div>`;
                        }

                        const senderLiveStatus = userPresenceMap[msg.userId] ? userPresenceMap[msg.userId].status : 'unknown';
                        const statusColorClass = senderLiveStatus === 'online' ? 'text-green-500' : (senderLiveStatus === 'offline' ? 'text-red-500' : 'text-gray-500');
                        const statusText = senderLiveStatus === 'online' ? '[ONLINE]' : '[OFFLINE]';


                        messageElement.className = `${alignmentClass} mb-3`;
                        messageElement.dataset.timestamp = msg.timestamp;
                        messageElement.innerHTML = `
                            <div class="max-w-[80%] p-3.5 rounded-md shadow-inner ${bubbleColorClass} break-words font-['Roboto_Mono']">
                                <div class="text-xs md:text-sm font-bold ${senderColorClass} mb-1 flex items-center">
                                    <span class="profile-pic-thumbnail mr-2 flex items-center justify-center" data-user-id="${msg.userId}">${senderProfilePicUrl}</span>
                                    <span>${senderName}</span>
                                    <span class="status-text ${statusColorClass}" data-user-id="${msg.userId}">${statusText}</span>
                                </div>
                                ${contentHtml}
                                <div class="text-xs text-right opacity-70 ${textColorClass} mt-2">${timeString}</div>
                                ${msg.userId === currentUserId && msg.timestamp ? `<div class="my-message-seen-status text-right text-xs text-gray-400 mt-1 hidden" data-message-timestamp="${msg.timestamp}"></div>` : ''}
                            </div>
                        `;
                        if (currentTypingIndicator && currentTypingIndicator.parentNode === messageArea) {
                            messageArea.insertBefore(messageElement, currentTypingIndicator);
                        } else {
                            messageArea.appendChild(messageElement);
                        }

                        currentLastMessageTimestamp = Math.max(currentLastMessageTimestamp, msg.timestamp || 0);
                    });

                    if (currentTypingIndicator && currentTypingIndicator.parentNode === messageArea) {
                         messageArea.appendChild(currentTypingIndicator);
                    }

                    if (lastProcessedMessageTimestamp > 0) {
                        messagesArray.forEach(msg => {
                            if ((msg.timestamp || 0) > lastProcessedMessageTimestamp && msg.userId !== currentUserId) {
                                if (!currentPrivateChatUserId || (currentPrivateChatUserId && (msg.userId === currentPrivateChatUserId || msg.recipientId === currentUserId))) {
                                    if (chatSound) {
                                        chatSound.play().catch(e => console.log("Sound play prevented or failed:", e));
                                    }
                                    const senderNameForNotification = msg.displayName || `Unit-${msg.userId.substring(0, 4).toUpperCase()}`;
                                    let notificationBody = "";
                                    if (msg.text) {
                                        notificationBody = msg.text;
                                    } else if (msg.audioData) {
                                        notificationBody = "Audio Message";
                                    } else if (msg.type === 'image' || msg.type === 'gif') { // Notification for images and GIFs
                                        notificationBody = `${msg.type.toUpperCase()} Message`;
                                    }
                                    displayNotification(`New message from ${senderNameForNotification}`, notificationBody);
                                }
                            }
                        });
                    }
                    lastProcessedMessageTimestamp = currentLastMessageTimestamp;
                    
                    messageArea.scrollTop = messageArea.scrollHeight;
                    
                    updateAllMessageStatusesInUI();
                    updateMyLastReadMessageTimestamp();
                } else {
                    const noMessagesElement = document.createElement('div');
                    noMessagesElement.className = "text-center text-gray-500 mt-8 text-base font-['Roboto_Mono']";
                    noMessagesElement.textContent = `No data logs found in ${currentPrivateChatUserId ? 'this private channel.' : 'the public channel.'} Start new transmission.`;
                    
                    Array.from(messageArea.children).forEach(child => {
                        const childId = child.id;
                        if (childId !== 'loading-indicator' && childId !== 'typing-indicator') {
                            child.remove();
                        }
                    });
                    
                    if (currentLoadingIndicator) {
                        currentLoadingIndicator.remove();
                    }
                    messageArea.appendChild(noMessagesElement);

                    if (currentTypingIndicator && currentTypingIndicator.parentNode === messageArea) {
                        messageArea.appendChild(currentTypingIndicator);
                    }

                    lastProcessedMessageTimestamp = 0;
                    messageArea.scrollTop = messageArea.scrollHeight;
                }
            }, (error) => {
                console.error("[listenForMessages] Error fetching messages:", error);
                const currentLoadingIndicator = document.getElementById('loading-indicator');
                if (currentLoadingIndicator) {
                    currentLoadingIndicator.style.display = 'none';
                }
                alertMessage("Failed to retrieve data logs. Check connection.", 'red');
            });

            if (currentPrivateChatUserId) {
                privateMessageUnsubscribe = unsubscribe;
            } else {
                publicMessageUnsubscribe = unsubscribe;
            }
        }

        /**
         * Displays a custom alert message within the UI.
         * @param {string} message - The message to display.
         * @param {string} type - The type of alert ('red' for error, 'green' for success).
         */
        function alertMessage(message, type = 'blue') {
            const existingAlert = document.getElementById('app-alert');
            if (existingAlert) {
                existingAlert.remove();
            }

            let bgColorClass = 'bg-blue-600';
            if (type === 'red') bgColorClass = 'bg-red-700';
            else if (type === 'green') bgColorClass = 'bg-green-600';

            const alertDiv = document.createElement('div');
            alertDiv.id = 'app-alert';
            alertDiv.className = `fixed top-4 left-1/2 -translate-x-1/2 ${bgColorClass} text-white px-6 py-3 rounded-lg app-alert z-50 transform scale-0 opacity-0 border border-gray-700`;
            alertDiv.textContent = message;
            document.body.appendChild(alertDiv);

            setTimeout(() => {
                alertDiv.classList.remove('scale-0', 'opacity-0');
                alertDiv.classList.add('scale-100', 'opacity-100');
            }, 10);

            setTimeout(() => {
                alertDiv.classList.remove('scale-100', 'opacity-100');
                alertDiv.classList.add('scale-0', 'opacity-0');
                alertDiv.addEventListener('transitionend', () => alertDiv.remove(), { once: true });
            }, 3000);
        }
    </script>
</body>
</html>
