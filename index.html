<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tactical Chat Interface</title>
    <!-- Favicon for military icon -->
    <link rel="icon" href="https://upload.wikimedia.org/wikipedia/commons/e/ea/Tactical_symbol_Land_Forces_-_Motorized_infantry_-_Squad_-_NATO_APP-6A.svg" type="image/svg+xml">
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Custom scrollbar for message area - military green/grey */
        .message-area::-webkit-scrollbar {
            width: 8px;
        }

        .message-area::-webkit-scrollbar-track {
            background: #2d3748; /* Darker track */
            border-radius: 10px;
        }

        .message-area::-webkit-scrollbar-thumb {
            background: #4a5568; /* Muted grey thumb */
            border-radius: 10px;
        }

        .message-area::-webkit-scrollbar-thumb:hover {
            background: #6a7486; /* Slightly lighter on hover */
        }

        /* Styling for emoji picker */
        .emoji-picker {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(32px, 1fr));
            gap: 4px;
            padding: 12px;
            background-color: #1a202c; /* Dark background */
            border-radius: 8px; /* Slightly less rounded for a tactical feel */
            box-shadow: 0 4px 15px rgba(0, 255, 0, 0.2); /* Green glow effect */
            max-height: 250px;
            overflow-y: auto;
            position: absolute;
            bottom: calc(100% + 10px);
            left: 0;
            right: 0;
            z-index: 50;
            border: 1px solid #10b981; /* Accent green border */
        }

        .emoji-picker button {
            font-size: 28px;
            background: none;
            border: none;
            cursor: pointer;
            padding: 6px;
            border-radius: 4px; /* Sharper corners */
            transition: background-color 0.2s ease, transform 0.1s ease;
        }

        .emoji-picker button:hover {
            background-color: rgba(0, 255, 0, 0.1); /* Subtle green tint on hover */
            transform: scale(1.05);
        }

        .emoji-picker button:active {
            background-color: rgba(0, 255, 0, 0.2);
            transform: scale(0.98);
        }

        /* Custom alert message styling */
        .app-alert {
            box-shadow: 0 4px 15px rgba(0,0,0,0.4);
            transition: all 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            font-family: 'Roboto Mono', monospace; /* Technical font for alerts */
        }

        /* Recording specific styles */
        .record-button-active {
            animation: pulse-red 1s infinite;
        }

        @keyframes pulse-red {
            0% { box-shadow: 0 0 0 0 rgba(239, 68, 68, 0.7); }
            70% { box-shadow: 0 0 0 10px rgba(239, 68, 68, 0); }
            100% { box-shadow: 0 0 0 0 rgba(239, 68, 68, 0); }
        }

        /* Online status indicators */
        .status-dot {
            display: inline-block;
            width: 8px;
            height: 8px;
            border-radius: 50%;
            margin-left: 6px;
            vertical-align: middle;
            background-color: #ccc; /* Default grey for unknown/offline */
        }
        .status-dot.online {
            background-color: #10b981; /* Green */
        }
        .status-dot.offline {
            background-color: #ef4444; /* Red */
        }
        .status-text {
            font-size: 0.75rem; /* text-xs */
            margin-left: 4px;
            vertical-align: middle;
            opacity: 0.7;
        }
        .status-text.online {
            color: #10b981; /* Green */
        }
        .status-text.offline {
            color: #ef4444; /* Red */
        }

        /* Typing indicator specific styles */
        .typing-indicator {
            display: flex;
            align-items: center;
            font-size: 0.75rem; /* text-xs */
            color: #10b981; /* Green */
            opacity: 0.8;
            margin-top: 5px;
        }
        .typing-indicator span {
            animation: blink 1s infinite;
            animation-delay: var(--delay);
        }
        @keyframes blink {
            0%, 100% { opacity: 0; }
            50% { opacity: 1; }
        }

        /* Online Users Modal Styles */
        .online-users-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7); /* Semi-transparent dark overlay */
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 100;
        }

        .online-users-modal-content {
            background-color: #1a202c; /* Dark background */
            padding: 24px;
            border-radius: 8px;
            box-shadow: 0 8px 30px rgba(0, 255, 0, 0.3); /* Green glow */
            width: 90%;
            max-width: 400px;
            max-height: 80%;
            overflow-y: auto;
            border: 1px solid #10b981;
            position: relative; /* For close button positioning */
        }

        .online-users-modal-content h3 {
            font-size: 1.5rem;
            color: #10b981; /* Green */
            margin-bottom: 16px;
            text-align: center;
            font-weight: bold;
            text-transform: uppercase;
        }

        .online-users-modal-content ul {
            list-style: none;
            padding: 0;
            margin: 0;
        }

        .online-users-modal-content ul li {
            background-color: #2d3748; /* Slightly lighter dark */
            padding: 10px 15px;
            border-radius: 5px;
            margin-bottom: 8px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 1rem;
            color: #e2e8f0; /* Light gray */
            border: 1px solid #4a5568;
        }

        .online-users-modal-content ul li:last-child {
            margin-bottom: 0;
        }

        .modal-close-button {
            position: absolute;
            top: 10px;
            right: 10px;
            background: none;
            border: none;
            font-size: 1.5rem;
            color: #ef4444; /* Red */
            cursor: pointer;
            padding: 5px;
            line-height: 1;
            transition: transform 0.2s ease;
        }

        .modal-close-button:hover {
            transform: scale(1.1);
        }
    </style>
    <!-- Add Google Fonts for a technical look (e.g., Roboto Mono or Oxanium) -->
    <link href="https://fonts.googleapis.com/css2?family=Roboto+Mono:wght@400;700&family=Oxanium:wght@400;700&display=swap" rel="stylesheet">
</head>
<body class="bg-gray-950 min-h-screen flex items-center justify-center p-0 font-['Roboto_Mono'] text-green-300 selection:bg-green-500 selection:text-white">

    <!-- Password Entry Screen -->
    <div id="password-screen" class="absolute inset-0 bg-gray-950 flex items-center justify-center z-50">
        <div class="bg-gray-900 p-8 rounded-lg shadow-xl border border-gray-700 text-center flex flex-col gap-6 w-11/12 max-w-sm">
            <h2 class="text-xl md:text-2xl font-bold text-green-400 tracking-wider uppercase font-['Oxanium']">Access Protocol</h2>
            <p class="text-gray-400 text-sm">Enter security key to proceed.</p>
            <input
                type="password"
                id="password-input"
                placeholder="Security Key"
                class="p-3 rounded-sm border border-green-700 focus:outline-none focus:ring-1 focus:ring-green-500 bg-gray-700 text-green-300 text-base transition duration-200"
            />
            <button
                id="login-button"
                class="bg-green-600 hover:bg-green-500 active:bg-green-700 text-white font-bold py-3 px-6 rounded-sm transition duration-300 ease-in-out shadow-lg hover:shadow-xl focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-green-500 border border-green-700 w-full"
            >
                Authorize
            </button>
            <p id="password-error" class="text-red-500 text-sm hidden">Access Denied. Invalid Key.</p>
        </div>
    </div>

    <!-- Main Chat Container: Industrial, dark panel look - Initially hidden -->
    <div id="chat-app-container" class="bg-gray-900 rounded-lg shadow-xl overflow-hidden w-full h-screen sm:h-[95vh] sm:max-h-[900px] sm:w-[90vw] sm:max-w-5xl flex flex-col border border-gray-700 transition-all duration-300 ease-in-out hidden">
        <!-- Chat Header -->
        <div class="bg-gray-800 p-2 md:p-4 flex flex-col md:flex-row justify-between items-center gap-y-2 md:gap-x-3 shadow-inner border-b border-green-500 flex-shrink-0">
            <h1 class="text-lg md:text-2xl font-bold text-green-400 text-center md:text-left tracking-wider uppercase font-['Oxanium']">Tactical Comms</h1>
            <!-- User Info and Name Setting Controls -->
            <div class="flex flex-col md:flex-row items-center md:justify-end gap-y-1 md:gap-x-2 w-full md:w-auto">
                <div id="user-info" class="text-xs md:text-sm font-medium text-gray-400 flex items-center">
                    <span class="font-bold text-green-400">Unit:</span> <span id="display-user-id" class="font-extrabold text-green-300 ml-1">UNKNOWN</span> <span id="my-status-indicator" class="status-dot ml-2"></span>
                </div>
                <div class="flex items-center gap-1.5 w-full max-w-xs md:max-w-none md:w-auto">
                    <input
                        type="text"
                        id="display-name-input"
                        placeholder="Callsign"
                        class="p-1.5 rounded-sm border border-green-700 focus:outline-none focus:ring-1 focus:ring-green-500 bg-gray-700 text-green-300 text-xs md:text-sm flex-grow transition duration-200"
                        maxlength="15"
                    />
                    <button
                        id="set-display-name-button"
                        class="bg-green-600 hover:bg-green-500 active:bg-green-700 text-white text-xs md:text-sm font-semibold py-1.5 px-3 rounded-sm transition duration-300 ease-in-out shadow-md focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-green-500 border border-green-700"
                    >
                        Set Callsign
                    </button>
                </div>
                <!-- Online Users Indicator (New) -->
                <div id="online-users-indicator" class="flex items-center text-xs md:text-sm font-medium text-gray-400 ml-4 cursor-pointer hover:text-green-300 transition-colors duration-200" title="Click to see online users">
                    <span class="font-bold text-green-400">Online:</span> <span id="online-count" class="font-extrabold text-green-300 ml-1">0</span>
                </div>
            </div>
        </div>

        <!-- Message Area -->
        <div id="message-area" class="flex-grow p-4 md:p-6 overflow-y-auto space-y-4 message-area bg-gray-900 border-t border-b border-gray-800">
            <!-- Messages will be injected here by JavaScript -->
            <div id="loading-indicator" class="text-center text-gray-500 mt-8 text-sm md:text-base">Awaiting Transmission...</div>
            <!-- Typing indicator will be appended here -->
            <div id="typing-indicator" class="typing-indicator hidden">
                <span style="--delay: 0s;">.</span><span style="--delay: 0.2s;">.</span><span style="--delay: 0.4s;">.</span> Someone is typing...
            </div>
        </div>

        <!-- Message Input and Emoji/Voice Controls (Reduced Height) -->
        <div class="bg-gray-800 p-3 border-t border-gray-700 flex flex-col relative flex-shrink-0">
            <!-- Emoji Picker -->
            <div id="emoji-picker" class="emoji-picker hidden">
                <!-- Emojis will be dynamically added here -->
            </div>

            <!-- Row 1: Text Input -->
            <div class="flex-grow mb-2"> <!-- Reduced mb-3 to mb-2 -->
                <input
                    type="text"
                    id="message-input"
                    placeholder="Enter message protocol..."
                    class="w-full p-2 md:p-2.5 rounded-sm border border-gray-600 focus:outline-none focus:ring-2 focus:ring-green-500 bg-gray-700 text-green-300 text-sm md:text-lg transition duration-200"
                />
            </div>

            <!-- Row 2: Send Button and Multimedia Buttons -->
            <div class="flex items-center gap-2 md:gap-3">
                <button
                    id="send-button"
                    class="bg-green-600 hover:bg-green-500 active:bg-green-700 text-white font-bold py-2 px-4 md:py-2.5 md:px-5 rounded-sm transition duration-300 ease-in-out shadow-lg hover:shadow-xl focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-green-500 border border-green-700 flex-shrink-0"
                >
                    Transmit
                </button>

                <div class="flex-grow"></div> <!-- Spacer to push buttons to the right -->

                <!-- Voice Recording Buttons -->
                <button
                    id="record-voice-button"
                    class="text-lg md:text-xl p-1.5 rounded-full bg-red-700 hover:bg-red-600 active:bg-red-800 text-white transition duration-300 ease-in-out shadow-sm hover:shadow-md focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-red-500 border border-red-800 flex-shrink-0"
                    title="Record Audio Log"
                >
                    🎤
                </button>
                <button
                    id="stop-record-button"
                    class="text-xs md:text-sm p-1 md:p-1.5 rounded-sm bg-red-600 hover:bg-red-500 active:bg-red-700 text-white font-semibold hidden transition duration-300 ease-in-out shadow-sm hover:shadow-md focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-red-400 border border-red-700 flex-shrink-0"
                    title="Terminate Recording"
                >
                    🛑 Stop
                </button>
                <button
                    id="send-voice-button"
                    class="bg-lime-600 hover:bg-lime-500 active:bg-lime-700 text-white font-bold py-1.5 px-3 md:py-1.5 px-3.5 rounded-sm hidden transition duration-300 ease-in-out shadow-md hover:shadow-lg focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-lime-500 border border-lime-700 flex-shrink-0"
                    title="Transmit Audio Log"
                >
                    ▶️ Send
                </button>
                <span id="recording-status" class="text-red-500 font-semibold hidden whitespace-nowrap ml-2 text-xs">Recording Audio...</span> <!-- Reduced font size -->

                <!-- Image Input and Send Button -->
                <label for="image-input"
                    class="text-lg md:text-xl p-1.5 rounded-full bg-blue-700 hover:bg-blue-600 active:bg-blue-800 text-white transition duration-300 ease-in-out shadow-sm hover:shadow-md cursor-pointer focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500 border border-blue-800 flex-shrink-0"
                    title="Attach Image"
                    id="image-button-label"
                >
                    📸
                    <input type="file" id="image-input" accept="image/*" class="hidden">
                </label>

                <button
                    id="send-image-button"
                    class="bg-blue-600 hover:bg-blue-500 active:bg-blue-700 text-white font-bold py-1.5 px-3 md:py-1.5 px-3.5 rounded-sm hidden transition duration-300 ease-in-out shadow-md hover:shadow-lg focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500 border border-blue-700 flex-shrink-0"
                    title="Transmit Image"
                >
                    🖼️ Send
                </button>
                <span id="image-preview-status" class="text-blue-500 font-semibold hidden whitespace-nowrap ml-2 text-xs">Image ready...</span> <!-- Reduced font size -->

                <!-- Emoji Button -->
                <button
                    id="emoji-button"
                    class="text-lg md:text-xl p-1.5 rounded-full bg-gray-700 hover:bg-gray-600 active:bg-gray-800 text-yellow-300 transition duration-300 ease-in-out shadow-sm hover:shadow-md focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-gray-400 border border-gray-600 flex-shrink-0"
                    title="Insert Protocol Icon"
                >
                    😊
                </button>
            </div>
        </div>
    </div>

    <!-- Online Users Modal (New) -->
    <div id="online-users-modal" class="online-users-modal hidden">
        <div class="online-users-modal-content">
            <button class="modal-close-button" id="online-users-close-button">&times;</button>
            <h3>Online Operatives</h3>
            <ul id="online-users-list">
                <!-- Online users will be dynamically inserted here -->
            </ul>
        </div>
    </div>

    <!-- Hidden audio element for chat notification sound -->
    <audio id="chat-sound" preload="auto">
        <source src="data:audio/mpeg;base64,SUQzBAAAAAAAI1RTU0UAAAAPAAADTGF2ZjU2LjQwLjEwMABMVU0zLjEwMFpDbgAAAAAAAAAAAAAAAAAAAAAAAAAA//tDEAAAKgAAAHwAAAEyAAABtAAAAYABxAAAk0AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD/8xMNAAsAAGAAAAhCQgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP/7QxAAAAoAAAB8AAAAQjAAABtAAAEyAAACwAAAB8AAALAAAATjAAADQAAAAeAAAAPAAAAhCQAQCAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP/zEzUAGIAAAAYAAAAvQgAAAIAAP/zEzNABsAAAAYAAABLkIgAAAAAA//tDcQAAoAAAAHwAAAEIeXRhY3RTAAAAJGNvcHlyaWdodCBPc2NhciBTeW50aCBTb2x1dGlvbnNQAQAAAABpYW1lAAAAACQAAAEAAAP/zEzUAAwAAAZAAAAAtQgAAAAAAAAAAP/zEzUAYgAAABcAAAAEQmQAAAAeAAAAPAAAAhCQAQCAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP/zEzUAAwAAAZAAAACvQgAAAAAAAAAAP/zEzUAGIAAAAYAAABLkIgAAAAAA//tDcQAAoAAAAHwAAAEIeXRhY3RTAAAAJGNvcPlyaWdodCBPc2NhciBTeW50aCBTb2x1dGlvbnNQAQAAAABiYW1lAAAAACQAAAEAAAP/zEzUAAwAAAZAAAACvQgAAAAAAAAAAP/zEzUAYgAAABcAAAAEQmQAAAAeAAAAPAAAAhCQAQCAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP/zEzUAAwAAAZAAAACvQgAAAAAAAAAAP/zEzUAGIAAAAYAAABLkIgAAAAAA//tDcQAAoAAAAHwAAAEIeXRhZGVhAAAkY29weXJpZ2h0IE9zY2FyIFN5bnRoc1AFAAAAZAAAAAQAAAIAAAABAAAD/8xM1ABiAAAAFwAAAASEIAAAAHgAAADwAAAAIUgAAEIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD/8xM1AAMAAAGQAAAAy0IAAAAAAAAAAA==" type="audio/mpeg">
        Your browser does not support the audio element.
    </audio>

    <script type="module">
        // Import Firebase functions from the SDKs
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.9.1/firebase-app.js";
        import { getDatabase, ref, push, onValue, set, onDisconnect, serverTimestamp, get, query, orderByChild, remove, child, update } from "https://www.gstatic.com/firebasejs/11.9.1/firebase-database.js";

        // Your web app's Firebase configuration (provided by the user)
        const firebaseConfig = {
          apiKey: "AIzaSyB2GAHcBAXb_vni8t7sVzkzcaE1AeOGagk",
          authDomain: "rexcomms-d6d98.firebaseapp.com",
          databaseURL: "https://rexcomms-d6d98-default-rtdb.asia-southeast1.firebasedatabase.app",
          projectId: "rexcomms-d6d98",
          storageBucket: "rexcomms-d6d98.firebasestorage.app",
          messagingSenderId: "1050880314920",
          appId: "1:1050880314920:web:0675ceb39cacf69fa3ef1d"
            
        };

        // Initialize Firebase
        const app = initializeApp(firebaseConfig);
        const db = getDatabase(app);

        // Access global variables for app ID
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';

        // DOM elements for password screen
        const passwordScreen = document.getElementById('password-screen');
        const passwordInput = document.getElementById('password-input');
        const loginButton = document.getElementById('login-button');
        const passwordError = document.getElementById('password-error');
        const chatAppContainer = document.getElementById('chat-app-container');

        // DOM elements for chat interface
        const messageInput = document.getElementById('message-input');
        const sendButton = document.getElementById('send-button');
        const messageArea = document.getElementById('message-area');
        const displayUserId = document.getElementById('display-user-id');
        const loadingIndicator = document.getElementById('loading-indicator');
        const emojiButton = document.getElementById('emoji-button');
        const emojiPicker = document.getElementById('emoji-picker');
        const displayNameInput = document.getElementById('display-name-input');
        const setDisplayNameButton = document.getElementById('set-display-name-button');
        const chatSound = document.getElementById('chat-sound');
        const myStatusIndicator = document.getElementById('my-status-indicator');
        const typingIndicatorElement = document.getElementById('typing-indicator'); // Typing indicator element

        // Voice message elements
        const recordVoiceButton = document.getElementById('record-voice-button');
        const stopRecordButton = document.getElementById('stop-record-button');
        const sendVoiceButton = document.getElementById('send-voice-button');
        const recordingStatus = document.getElementById('recording-status');

        // New image message elements
        const imageInput = document.getElementById('image-input');
        const sendImageButton = document.getElementById('send-image-button');
        const imageButtonLabel = document.getElementById('image-button-label');
        const imagePreviewStatus = document.getElementById('image-preview-status');

        // Online Users Modal elements (New)
        const onlineUsersIndicator = document.getElementById('online-users-indicator');
        const onlineCountSpan = document.getElementById('online-count');
        const onlineUsersModal = document.getElementById('online-users-modal');
        const onlineUsersList = document.getElementById('online-users-list');
        const onlineUsersCloseButton = document.getElementById('online-users-close-button');


        // Voice message variables
        let mediaRecorder;
        let audioChunks = [];
        let audioBlob = null;
        let audioMimeType = '';

        // Image message variables
        let selectedImageBase64 = null;
        let selectedImageMimeType = null;

        // Typing indicator variables
        let typingTimeout = null;
        const TYPING_INDICATOR_TIMEOUT_MS = 3000; // Time after which typing status is cleared

        // Persistent User ID and Display Name
        let currentUserId = localStorage.getItem('tacticalChatUserId');
        if (!currentUserId) {
            currentUserId = crypto.randomUUID();
            localStorage.setItem('tacticalChatUserId', currentUserId);
        }
        let currentDisplayName = localStorage.getItem('chatDisplayName') || `Unit-${currentUserId.substring(0, 4).toUpperCase()}`;

        // Global map to store online status and typing status of all users
        let userPresenceMap = {};
        // Timestamp of the last message processed for sound/notification
        let lastProcessedMessageTimestamp = 0;

        const CORRECT_PASSWORD = "rexchat";

        /**
         * Requests notification permission from the user.
         */
        function requestNotificationPermission() {
            if (!("Notification" in window)) {
                console.log("This browser does not support desktop notification");
                return;
            }

            if (Notification.permission === "granted") {
                console.log("Notification permission already granted.");
            } else if (Notification.permission !== "denied") {
                Notification.requestPermission().then(permission => {
                    if (permission === "granted") {
                        console.log("Notification permission granted.");
                    } else {
                        console.log("Notification permission denied.");
                    }
                });
            }
        }

        /**
         * Displays a browser notification for a new message.
         * @param {string} title - The title of the notification.
         * @param {string} body - The body text of the notification.
         */
        function displayNotification(title, body) {
            if (Notification.permission === "granted" && !document.hidden) {
                // If permission is granted and the tab is active, no need for notification
                return;
            } else if (Notification.permission === "granted") {
                new Notification(title, {
                    body: body,
                    icon: 'https://placehold.co/48x48/00FF00/FFFFFF?text=Chat', // Placeholder icon
                    vibrate: [200, 100, 200]
                });
            }
        }

        /**
         * Resets the input area to its default state (text input visible).
         */
        function resetInputArea() {
            messageInput.classList.remove('hidden');
            sendButton.classList.remove('hidden');
            emojiButton.classList.remove('hidden'); // Show emoji button
            recordVoiceButton.classList.remove('hidden'); // Show record button
            imageButtonLabel.classList.remove('hidden'); // Show image button label

            // Hide voice specific controls
            stopRecordButton.classList.add('hidden');
            sendVoiceButton.classList.add('hidden');
            recordingStatus.classList.add('hidden');
            
            // Hide image specific controls
            sendImageButton.classList.add('hidden');
            imagePreviewStatus.classList.add('hidden');
            imageInput.value = ''; // Clear file input
            selectedImageBase64 = null;
            selectedImageMimeType = null;

            // Clear typing status when input area is reset (e.g., after sending)
            setMyTypingStatus(false);
            
            // Always scroll to the bottom after resetting input area (e.g., after sending a message)
            messageArea.scrollTop = messageArea.scrollHeight;
        }

        /**
         * Initializes the chat application after successful password authentication.
         */
        function initializeChatApp() {
            // Ensure password screen is hidden and chat container is displayed
            passwordScreen.style.display = 'none';
            chatAppContainer.style.display = 'flex'; // Assuming chatAppContainer uses flexbox

            initializeDisplayName();
            setupPresence();
            listenForMessages();
            populateEmojiPicker(); // Make sure emoji picker is populated on app start
            resetInputArea(); // Call reset to set initial UI state and scroll to bottom
            requestNotificationPermission(); // Request notification permission on app initialization
            
            // Attach all event listeners here, ensuring DOM elements are ready
            sendButton.addEventListener('click', sendMessage);
            messageInput.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    sendMessage();
                }
            });

            // Typing indicator event listener for text input
            messageInput.addEventListener('input', () => {
                setMyTypingStatus(true); // Start typing
                clearTimeout(typingTimeout);
                typingTimeout = setTimeout(() => {
                    setMyTypingStatus(false); // Stop typing after timeout
                }, TYPING_INDICATOR_TIMEOUT_MS);
            });

            emojiButton.addEventListener('click', (event) => {
                event.stopPropagation();
                emojiPicker.classList.toggle('hidden');
            });

            document.addEventListener('click', (event) => {
                if (!emojiPicker.contains(event.target) && !emojiButton.contains(event.target)) {
                    emojiPicker.classList.add('hidden');
                }
            });

            setDisplayNameButton.addEventListener('click', setDisplayName);
            displayNameInput.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    setDisplayName();
                }
            });

            recordVoiceButton.addEventListener('click', startRecording);
            stopRecordButton.addEventListener('click', stopRecording);
            sendVoiceButton.addEventListener('click', sendVoiceMessage);

            imageInput.addEventListener('change', handleImageSelection);
            sendImageButton.addEventListener('click', sendImageMessage);

            // Online Users Modal Event Listeners
            onlineUsersIndicator.addEventListener('click', showOnlineUsersModal);
            onlineUsersCloseButton.addEventListener('click', hideOnlineUsersModal);

            // Add scroll listener for read receipts
            messageArea.addEventListener('scroll', updateMyLastReadMessageTimestamp);
        }

        /**
         * Handles the login attempt.
         */
        function handleLogin() {
            if (passwordInput.value === CORRECT_PASSWORD) {
                initializeChatApp();
            } else {
                passwordError.classList.remove('hidden');
                passwordInput.value = ''; // Clear input on wrong password
            }
        }

        // Always show the password screen and attach event listeners for login
        passwordScreen.classList.remove('hidden');
        passwordScreen.style.display = 'flex'; // Ensure password screen is visible
        loginButton.addEventListener('click', handleLogin);
        passwordInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                handleLogin();
            }
        });


        /**
         * Loads the display name from local storage or sets a default.
         * Updates the display name input and the header display.
         */
        function initializeDisplayName() {
            const storedName = localStorage.getItem('chatDisplayName');
            if (storedName) {
                currentDisplayName = storedName;
            }
            displayNameInput.value = currentDisplayName;
            displayUserId.textContent = currentDisplayName;
            console.log("Current User ID (locally generated):", currentUserId);
            console.log("Current Callsign:", currentDisplayName);
        }

        /**
         * Sets the user's display name and saves it to local storage.
         */
        function setDisplayName() {
            const newName = displayNameInput.value.trim();
            if (newName) {
                currentDisplayName = newName;
                localStorage.setItem('chatDisplayName', newName);
                displayUserId.textContent = newName;
                alertMessage(`Callsign set to "${newName}"`, 'green');
                // Also update presence info with new display name
                updateMyPresence(currentDisplayName, 'online');
            } else {
                alertMessage("Callsign cannot be empty.", 'red');
            }
        }

        /**
         * Sets up the Firebase Realtime Database presence system for the current user.
         */
        function setupPresence() {
            const connectedRef = ref(db, '.info/connected');
            const currentUserPresenceRef = ref(db, `artifacts/${appId}/public/data/users_presence/${currentUserId}`);

            onValue(connectedRef, (snapshot) => {
                if (snapshot.val() === true) {
                    // We are connected. Set our status to online.
                    // Include isTyping and lastReadMessageTimestamp
                    set(currentUserPresenceRef, {
                        displayName: currentDisplayName,
                        status: 'online',
                        isTyping: false, // Default to not typing
                        lastReadMessageTimestamp: serverTimestamp() // Update on connect
                    });
                    // Set up onDisconnect to mark us offline and not typing when connection is lost/app closed
                    onDisconnect(currentUserPresenceRef).set({
                        displayName: currentDisplayName,
                        status: 'offline',
                        isTyping: false,
                        timestamp: serverTimestamp()
                    });
                    myStatusIndicator.classList.remove('offline');
                    myStatusIndicator.classList.add('online');
                } else {
                    // We are disconnected from Firebase. Update UI, onDisconnect will handle DB.
                    myStatusIndicator.classList.remove('online');
                    myStatusIndicator.classList.add('offline');
                }
            });

            // Listen for all users' presence changes to update the global map and UI
            onValue(ref(db, `artifacts/${appId}/public/data/users_presence`), (snapshot) => {
                userPresenceMap = {}; // Clear map to rebuild
                let anyOtherUserTyping = false;
                let onlineUsersCount = 0; // Initialize online user count

                onlineUsersList.innerHTML = ''; // Clear previous list

                snapshot.forEach((childSnapshot) => {
                    const userData = childSnapshot.val();
                    const userId = childSnapshot.key;
                    if (userData.status === 'online') {
                        userPresenceMap[userId] = userData;
                        onlineUsersCount++; // Increment count for each online user

                        // Add user to the online users list in the modal
                        const listItem = document.createElement('li');
                        listItem.textContent = userData.displayName || `Unit-${userId.substring(0, 4).toUpperCase()}...`;
                        onlineUsersList.appendChild(listItem);

                        if (userId !== currentUserId && userData.isTyping) {
                            anyOtherUserTyping = true;
                        }
                    }
                });
                onlineCountSpan.textContent = onlineUsersCount; // Update the displayed count
                updateAllMessageStatusesInUI(); // Update status for all displayed messages

                // Update typing indicator visibility
                if (anyOtherUserTyping) {
                    typingIndicatorElement.classList.remove('hidden');
                    // Scroll to bottom to show typing indicator if it's new
                    messageArea.scrollTop = messageArea.scrollHeight;
                } else {
                    typingIndicatorElement.classList.add('hidden');
                }
            });
        }

        /**
         * Sets the current user's typing status in Firebase.
         * @param {boolean} isTyping - True if typing, false otherwise.
         */
        function setMyTypingStatus(isTyping) {
            const currentUserPresenceRef = ref(db, `artifacts/${appId}/public/data/users_presence/${currentUserId}`);
            set(currentUserPresenceRef, {
                ...userPresenceMap[currentUserId], // Preserve other data like displayName, status, lastReadMessageTimestamp
                isTyping: isTyping,
                timestamp: serverTimestamp() // Update timestamp to keep presence active
            });
        }

        /**
         * Updates the current user's last read message timestamp.
         */
        function updateMyLastReadMessageTimestamp() {
            // Only update if scrolled near the bottom
            const tolerance = 50; // pixels from the bottom
            if (messageArea.scrollHeight - messageArea.scrollTop <= messageArea.clientHeight + tolerance) {
                // Get the timestamp of the last message displayed
                const allMessageElements = messageArea.querySelectorAll('.mb-3'); // Select all message bubbles
                const lastMessageElement = allMessageElements.length > 0 ? allMessageElements[allMessageElements.length - 1] : null;

                if (lastMessageElement && lastMessageElement.dataset.timestamp) { // Check if it's a message that needs seen status
                    const lastMessageTimestamp = parseInt(lastMessageElement.dataset.timestamp);
                    const currentUserPresenceRef = ref(db, `artifacts/${appId}/public/data/users_presence/${currentUserId}`);
                    // Only update if the new timestamp is greater than the current one in DB
                    if (!userPresenceMap[currentUserId] || userPresenceMap[currentUserId].lastReadMessageTimestamp < lastMessageTimestamp) {
                        set(currentUserPresenceRef, {
                            ...userPresenceMap[currentUserId], // Preserve other data
                            lastReadMessageTimestamp: lastMessageTimestamp
                        });
                    }
                }
            }
        }


        /**
         * Updates the status indicator for all messages in the UI based on userPresenceMap.
         */
        function updateAllMessageStatusesInUI() {
            document.querySelectorAll('.status-indicator').forEach(indicator => {
                const userId = indicator.dataset.userId;
                const userStatus = userPresenceMap[userId] ? userPresenceMap[userId].status : 'unknown';

                indicator.textContent = userStatus === 'online' ? '[ONLINE]' : '[OFFLINE]';
                indicator.classList.remove('online', 'offline');
                if (userStatus === 'online') {
                    indicator.classList.add('online');
                    indicator.style.color = '#10b981'; /* Tailwind green-500 */
                } else {
                    indicator.classList.add('offline');
                    indicator.style.color = '#ef4444'; /* Tailwind red-500 */
                }
            });

            // Update read receipts for my messages
            document.querySelectorAll('.my-message-seen-status').forEach(seenStatusDiv => {
                const messageElement = seenStatusDiv.closest('.mb-3'); // Get the parent message element
                if (!messageElement) return; // Should not happen if HTML structure is correct

                const messageTimestamp = parseInt(messageElement.dataset.timestamp);
                const seenBy = [];
                for (const userId in userPresenceMap) {
                    if (userId !== currentUserId && userPresenceMap[userId].status === 'online' &&
                        userPresenceMap[userId].lastReadMessageTimestamp &&
                        userPresenceMap[userId].lastReadMessageTimestamp >= messageTimestamp) {
                        seenBy.push(userPresenceMap[userId].displayName || `Unit-${userId.substring(0,4).toUpperCase()}`);
                    }
                }

                if (seenBy.length > 0) {
                    seenStatusDiv.textContent = `Seen by: ${seenBy.join(', ')}`;
                    seenStatusDiv.classList.remove('hidden');
                } else {
                    seenStatusDiv.classList.add('hidden');
                }
            });
        }

        /**
         * Shows the online users modal.
         */
        function showOnlineUsersModal() {
            onlineUsersModal.classList.remove('hidden');
        }

        /**
         * Hides the online users modal.
         */
        function hideOnlineUsersModal() {
            onlineUsersModal.classList.add('hidden');
        }

        // Array of common emojis (renamed to 'protocol_icons' for military theme)
        const protocol_icons = [
            '👍', '✅', '❌', '⚠️', '🚨', '📍', '🗺️', '📡', '⚙️', '🛡️',
            '⬆️', '⬇️', '⬅️', '➡️', '🧊', '🔥', '💧', '💨', '☀️', '☁️', '🌧️', '❄️',
            '🎯', '💣', '🚩', '💡', '💬', '🎶', '🔇', '🔈', '🔊', '🔬',
            '🔎', '🔑', '🔗', '🔒', '🔓',
            '📊', '📈', '📉', '📊', '📝'
        ];

        /**
         * Populates the emoji picker with buttons for each emoji.
         */
        function populateEmojiPicker() {
            emojiPicker.innerHTML = ''; // Clear previous emojis to prevent duplicates if called multiple times
            protocol_icons.forEach(emoji => {
                const button = document.createElement('button');
                button.textContent = emoji;
                button.title = emoji; // Add title for accessibility
                button.addEventListener('click', () => {
                    messageInput.value += emoji; // Append emoji to input
                    emojiPicker.classList.add('hidden'); // Hide picker after selection
                    messageInput.focus(); // Keep focus on input
                });
                emojiPicker.appendChild(button);
            });
        }

        /**
         * Cleans up old messages, retaining only the latest 30.
         */
        async function cleanupOldMessages() {
            const messagesRef = ref(db, `artifacts/${appId}/public/data/messages`);
            try {
                // Get a snapshot of all messages, ordered by timestamp
                const snapshot = await get(query(messagesRef, orderByChild('timestamp')));
                
                if (snapshot.exists()) {
                    const messagesToDelete = [];
                    const messagesArray = [];

                    snapshot.forEach(childSnapshot => {
                        messagesArray.push({ id: childSnapshot.key, ...childSnapshot.val() });
                    });

                    // Sort messages by timestamp to ensure correct ordering for deletion
                    messagesArray.sort((a, b) => (a.timestamp || 0) - (b.timestamp || 0));

                    if (messagesArray.length > 30) {
                        // Identify messages to delete (all except the last 30)
                        for (let i = 0; i < messagesArray.length - 30; i++) {
                            messagesToDelete.push(messagesArray[i].id);
                        }

                        // Delete each identified message
                        const deletePromises = messagesToDelete.map(msgId => {
                            return remove(child(messagesRef, msgId));
                        });
                        await Promise.all(deletePromises);
                        console.log(`Cleaned up ${messagesToDelete.length} old messages.`);
                    }
                }
            } catch (error) {
                console.error("Error cleaning up old messages:", error);
            }
        }


        /**
         * Sends a message to the Firebase Realtime Database.
         * This function now handles text, audio, and image messages.
         */
        async function sendMessage() {
            const messageText = messageInput.value.trim();

            if (messageText && currentUserId) { // Text message
                try {
                    const messagesRef = ref(db, `artifacts/${appId}/public/data/messages`);
                    await push(messagesRef, {
                        userId: currentUserId,
                        displayName: currentDisplayName,
                        text: messageText,
                        timestamp: serverTimestamp()
                    });
                } catch (error) {
                    console.error("Error sending message:", error);
                    alertMessage("Transmission failed. Retrying...", 'red');
                } finally {
                    messageInput.value = ''; // Clear input field
                    resetInputArea(); // Reset input area after sending and scroll to bottom
                    cleanupOldMessages(); // Clean up old messages after sending
                }
            } else if (audioBlob && currentUserId) { // Audio message
                sendVoiceMessage();
            } else if (selectedImageBase64 && currentUserId) { // Image message
                sendImageMessage();
            } else {
                alertMessage("No content to transmit.", 'red');
                resetInputArea(); // Scroll to bottom in case of no content
            }
        }

        /**
         * Starts recording audio.
         */
        async function startRecording() {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                // Check for MediaRecorder support. Use 'audio/webm' as preferred.
                const options = { mimeType: 'audio/webm' };
                if (!MediaRecorder.isTypeSupported(options.mimeType)) {
                    options.mimeType = 'audio/ogg'; // Fallback for some browsers
                    if (!MediaRecorder.isTypeSupported(options.mimeType)) {
                        options.mimeType = 'audio/wav'; // Another fallback
                        if (!MediaRecorder.isTypeSupported(options.mimeType)) {
                            alertMessage("Audio recording not supported in this browser.", 'red');
                            return;
                        }
                    }
                }
                
                mediaRecorder = new MediaRecorder(stream, options);
                audioMimeType = options.mimeType; // Store the actual mime type being used
                audioChunks = [];

                mediaRecorder.ondataavailable = event => {
                    audioChunks.push(event.data);
                };

                mediaRecorder.onstop = () => {
                    audioBlob = new Blob(audioChunks, { type: audioMimeType });
                    // Correctly toggle buttons after stopping recording
                    stopRecordButton.classList.add('hidden'); // Hide stop
                    sendVoiceButton.classList.remove('hidden'); // Show send
                    recordVoiceButton.classList.add('hidden'); // Ensure record is still hidden until sent
                    recordingStatus.classList.add('hidden'); // Hide status
                };

                mediaRecorder.start();
                recordVoiceButton.classList.add('record-button-active'); // Add pulsing animation
                
                // Hide other input methods
                recordVoiceButton.classList.add('hidden'); // Hide record button itself
                stopRecordButton.classList.remove('hidden'); // Show stop button
                recordingStatus.classList.remove('hidden'); // Show recording status
                sendVoiceButton.classList.add('hidden'); // Hide send voice button
                messageInput.classList.add('hidden'); // Hide text input
                sendButton.classList.add('hidden'); // Hide text send button
                emojiButton.classList.add('hidden'); // Hide emoji button
                imageButtonLabel.classList.add('hidden'); // Hide image button
                sendImageButton.classList.add('hidden'); // Hide send image button
                imagePreviewStatus.classList.add('hidden'); // Hide image status

                setMyTypingStatus(false); // Ensure typing status is off when recording
                alertMessage("Audio log initiated...", 'blue');

            } /* catches (err) */ catch (err) {
                console.error("Error accessing microphone:", err);
                alertMessage("Failed to access microphone. Permission required for audio log.", 'red');
                resetInputArea(); // Reset UI in case of error
            }
        }

        /**
         * Stops recording audio.
         */
        function stopRecording() {
            if (mediaRecorder && mediaRecorder.state !== 'inactive') {
                mediaRecorder.stop();
                mediaRecorder.stream.getTracks().forEach(track => track.stop()); // Stop microphone access
                alertMessage("Audio log terminated. Ready for transmit.", 'blue');
            }
        }

        /**
         * Sends a voice message to the Firebase Realtime Database.
         */
        async function sendVoiceMessage() {
            if (audioBlob && currentUserId) {
                // Convert Blob to Base64 string
                const reader = new FileReader();
                reader.onloadend = async () => {
                    const base64data = reader.result; // This will be data:audio/webm;base64,...

                    try {
                        const messagesRef = ref(db, `artifacts/${appId}/public/data/messages`);
                        await push(messagesRef, {
                            userId: currentUserId,
                            displayName: currentDisplayName,
                            audioData: base64data, // Store base64 audio
                            audioMimeType: audioMimeType, // Store mime type
                            timestamp: serverTimestamp()
                        });
                    } catch (error) {
                        console.error("Error transmitting audio log:", error);
                        alertMessage("Failed to transmit audio log. It might be too large or an error occurred.", 'red');
                    } finally {
                        // Reset voice recording UI
                        audioBlob = null;
                        audioChunks = [];
                        audioMimeType = '';
                        resetInputArea(); // Reset input area after sending and scroll to bottom
                        cleanupOldMessages(); // Clean up old messages after sending
                    }
                };
                reader.readAsDataURL(audioBlob);
            } else {
                alertMessage("No audio log detected for transmission.", 'red');
                resetInputArea(); // Scroll to bottom if no audio
            }
        }

        /**
         * Handles image file selection.
         */
        function handleImageSelection(event) {
            const file = event.target.files[0];
            if (file) {
                if (!file.type.startsWith('image/')) {
                    alertMessage("Please select an image file.", 'red');
                    imageInput.value = ''; // Clear file input
                    selectedImageBase64 = null;
                    selectedImageMimeType = null;
                    resetInputArea();
                    return;
                }

                const reader = new FileReader();
                reader.onloadend = () => {
                    selectedImageBase64 = reader.result;
                    selectedImageMimeType = file.type;

                    // Show image send button and hide other input methods
                    sendImageButton.classList.remove('hidden');
                    imagePreviewStatus.classList.remove('hidden'); // Show status like "Image ready..."
                    
                    messageInput.classList.add('hidden');
                    sendButton.classList.add('hidden');
                    recordVoiceButton.classList.add('hidden');
                    stopRecordButton.classList.add('hidden');
                    sendVoiceButton.classList.add('hidden');
                    recordingStatus.classList.add('hidden');
                    emojiButton.classList.add('hidden'); // Hide emoji button when image is selected
                    imageButtonLabel.classList.add('hidden'); // Hide image button label itself

                    setMyTypingStatus(false); // Ensure typing status is off when selecting image
                    alertMessage("Image selected, ready for transmission.", 'blue');
                };
                reader.readAsDataURL(file);
            } else {
                selectedImageBase64 = null;
                selectedImageMimeType = null;
                resetInputArea(); // Scroll to bottom if no image
            }
        }

        /**
         * Sends an image message to the Firebase Realtime Database.
         */
        async function sendImageMessage() {
            if (selectedImageBase64 && currentUserId) {
                try {
                    const messagesRef = ref(db, `artifacts/${appId}/public/data/messages`);
                    await push(messagesRef, {
                        userId: currentUserId,
                        displayName: currentDisplayName,
                        imageData: selectedImageBase64,
                        imageMimeType: selectedImageMimeType,
                        timestamp: serverTimestamp()
                    });
                } catch (error) {
                    console.error("Error transmitting image:", error);
                    alertMessage("Failed to transmit image. It might be too large or an error occurred.", 'red');
                } finally {
                    resetInputArea(); // Reset input area after sending and scroll to bottom
                    cleanupOldMessages(); // Clean up old messages after sending
                }
            } else {
                alertMessage("No image detected for transmission.", 'red');
                resetInputArea(); // Scroll to bottom if no image
            }
        }


        /**
         * Listens for new messages from the Firebase Realtime Database in real-time.
         */
        function listenForMessages() {
            // Path for public chat data
            const messagesRef = ref(db, `artifacts/${appId}/public/data/messages`);

            onValue(messagesRef, (snapshot) => {
                loadingIndicator.style.display = 'none'; // Hide loading indicator once data starts coming
                
                // Clear all messages except the typing indicator (if present)
                Array.from(messageArea.children).forEach(child => {
                    if (child.id !== 'typing-indicator' && child.id !== 'loading-indicator') {
                        child.remove();
                    }
                });

                // Track the timestamp of the latest message in this snapshot to prevent re-triggering sound/notification
                let currentLastMessageTimestamp = 0;

                if (snapshot.exists()) {
                    const messagesData = snapshot.val();
                    const messagesArray = [];

                    // Convert object of messages into an array and sort by timestamp
                    for (const key in messagesData) {
                        messagesArray.push({ id: key, ...messagesData[key] });
                    }
                    // Sort by timestamp if available, otherwise by key (which Firebase uses for push IDs, often chronological)
                    messagesArray.sort((a, b) => (a.timestamp || 0) - (b.timestamp || 0));

                    messagesArray.forEach(msg => {
                        const messageElement = document.createElement('div');
                        let alignmentClass = '';
                        let bubbleColorClass = '';
                        let textColorClass = 'text-gray-200'; // Default text color for messages

                        // Use displayName if available, otherwise fallback to truncated userId
                        const senderName = msg.displayName || `Unit-${msg.userId.substring(0, 4).toUpperCase()}...`;
                        const senderColorClass = (msg.userId === currentUserId) ? 'text-green-400' : 'text-blue-400'; // Different color for sender name

                        if (msg.userId === currentUserId) {
                            alignmentClass = 'flex justify-end';
                            bubbleColorClass = 'bg-gray-700 border border-green-600'; /* My messages, green border */
                        } else {
                            alignmentClass = 'flex justify-start';
                            bubbleColorClass = 'bg-gray-800 border border-blue-600'; /* Other messages, blue border */
                        }

                        // Format timestamp if available
                        const date = msg.timestamp ? new Date(msg.timestamp) : null;
                        const timeString = date ? date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }) : 'Processing...';

                        let contentHtml = '';
                        if (msg.audioData) {
                            // Display audio player for voice messages
                            contentHtml = `
                                <audio controls class="w-full mt-2 rounded-md bg-gray-600 outline-none focus:outline-none focus:ring-1 focus:ring-green-400">
                                    <source src="${msg.audioData}" type="${msg.audioMimeType || 'audio/webm'}">
                                    Your browser does not support the audio element.
                                </audio>
                            `;
                            // If it's a voice message, show "Voice Message" or sender's name and "Voice"
                            let voiceMessageLabel = msg.userId === currentUserId ? "AUDIO LOG (OUTGOING)" : "AUDIO LOG (INCOMING)";
                            contentHtml = `<div class="font-semibold mb-1 text-xs uppercase tracking-wide ${senderColorClass}">${voiceMessageLabel}</div>` + contentHtml;
                        } else if (msg.imageData) {
                            // Display image message
                            contentHtml = `
                                <img src="${msg.imageData}" alt="User Image" class="max-w-full h-auto rounded-md mt-2 border border-gray-600 object-contain" style="max-height: 200px;">
                            `;
                            let imageMessageLabel = msg.userId === currentUserId ? "IMAGE LOG (OUTGOING)" : "IMAGE LOG (INCOMING)";
                            contentHtml = `<div class="font-semibold mb-1 text-xs uppercase tracking-wide ${senderColorClass}">${imageMessageLabel}</div>` + contentHtml;
                        }
                        else {
                            // Display text message
                            let messageText = msg.text;
                            contentHtml = `<div class="text-sm md:text-base ${textColorClass} tracking-tight">${messageText}</div>`;
                        }

                        // Get current status from the global map for this sender
                        const senderLiveStatus = userPresenceMap[msg.userId] ? userPresenceMap[msg.userId].status : 'unknown';
                        const statusColorClass = senderLiveStatus === 'online' ? 'text-green-500' : (senderLiveStatus === 'offline' ? 'text-red-500' : 'text-gray-500');
                        const statusText = senderLiveStatus === 'online' ? '[ONLINE]' : '[OFFLINE]';


                        messageElement.className = `${alignmentClass} mb-3`;
                        messageElement.dataset.timestamp = msg.timestamp; // Store timestamp for seen status
                        messageElement.innerHTML = `
                            <div class="max-w-[80%] p-3.5 rounded-md shadow-inner ${bubbleColorClass} break-words font-['Roboto_Mono']">
                                <div class="text-xs md:text-sm font-bold ${senderColorClass} mb-1 flex items-center">
                                    <span>${senderName}</span>
                                    <span class="status-text ${statusColorClass}" data-user-id="${msg.userId}">${statusText}</span>
                                </div>
                                ${contentHtml}
                                <div class="text-xs text-right opacity-70 ${textColorClass} mt-2">${timeString}</div>
                                ${msg.userId === currentUserId && msg.timestamp ? `<div class="my-message-seen-status text-right text-xs text-gray-400 mt-1 hidden" data-message-timestamp="${msg.timestamp}"></div>` : ''}
                            </div>
                        `;
                        // Insert new messages before the typing indicator
                        messageArea.insertBefore(messageElement, typingIndicatorElement);

                        // Update currentLastMessageTimestamp
                        currentLastMessageTimestamp = Math.max(currentLastMessageTimestamp, msg.timestamp || 0);
                    });

                    // Play sound/notification for NEW messages only after initial load
                    if (lastProcessedMessageTimestamp > 0) { // Check if it's not the very first load
                        messagesArray.forEach(msg => {
                            // Only trigger for messages newer than what was last processed and not from current user
                            if ((msg.timestamp || 0) > lastProcessedMessageTimestamp && msg.userId !== currentUserId) {
                                if (chatSound) {
                                    chatSound.play().catch(e => console.log("Sound play prevented or failed:", e));
                                }
                                // Display browser notification for new messages from others
                                const senderNameForNotification = msg.displayName || `Unit-${msg.userId.substring(0, 4).toUpperCase()}`;
                                let notificationBody = "";
                                if (msg.text) {
                                    notificationBody = msg.text;
                                } else if (msg.audioData) {
                                    notificationBody = "Audio Message";
                                } else if (msg.imageData) {
                                    notificationBody = "Image Message";
                                }
                                displayNotification(`New message from ${senderNameForNotification}`, notificationBody);
                            }
                        });
                    }
                    // Update global lastProcessedMessageTimestamp
                    lastProcessedMessageTimestamp = currentLastMessageTimestamp;
                    
                    // Always scroll to bottom after new messages are loaded
                    messageArea.scrollTop = messageArea.scrollHeight;
                    
                    // Update read receipts for all messages after new messages are added
                    updateAllMessageStatusesInUI();
                    updateMyLastReadMessageTimestamp(); // Also update my read status after messages load/scroll
                } else {
                    const noMessagesElement = document.createElement('div');
                    noMessagesElement.className = "text-center text-gray-500 mt-8 text-base font-['Roboto_Mono']";
                    noMessagesElement.textContent = "No data logs found. Start new transmission.";
                    messageArea.insertBefore(noMessagesElement, typingIndicatorElement); // Insert before typing indicator
                    lastProcessedMessageTimestamp = 0; // Reset if no messages
                    messageArea.scrollTop = messageArea.scrollHeight; // Scroll to bottom even if no messages
                }
            }, (error) => {
                console.error("Error fetching messages:", error);
                loadingIndicator.style.display = 'none';
                alertMessage("Failed to retrieve data logs. Check connection.", 'red');
            });
        }

        /**
         * Displays a custom alert message within the UI.
         * @param {string} message - The message to display.
         * @param {string} type - The type of alert ('red' for error, 'green' for success).
         */
        function alertMessage(message, type = 'blue') {
            const existingAlert = document.getElementById('app-alert');
            if (existingAlert) {
                existingAlert.remove();
            }

            let bgColorClass = 'bg-blue-600'; // Default blue
            if (type === 'red') bgColorClass = 'bg-red-700'; /* Darker red for errors */
            else if (type === 'green') bgColorClass = 'bg-green-600'; /* Standard green for success */

            const alertDiv = document.createElement('div');
            alertDiv.id = 'app-alert';
            alertDiv.className = `fixed bottom-4 left-1/2 -translate-x-1/2 ${bgColorClass} text-white px-6 py-3 rounded-lg app-alert z-50 transform scale-0 opacity-0 border border-gray-700`;
            alertDiv.textContent = message;
            document.body.appendChild(alertDiv);

            // Animate in
            setTimeout(() => {
                alertDiv.classList.remove('scale-0', 'opacity-0');
                alertDiv.classList.add('scale-100', 'opacity-100');
            }, 10);

            // Animate out after 3 seconds
            setTimeout(() => {
                alertDiv.classList.remove('scale-100', 'opacity-100');
                alertDiv.classList.add('scale-0', 'opacity-0');
                alertDiv.addEventListener('transitionend', () => alertDiv.remove(), { once: true });
            }, 3000);
        }
    </script>
</body>
</html>
